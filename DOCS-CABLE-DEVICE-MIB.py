# PySNMP SMI module. Autogenerated from smidump -f python DOCS-CABLE-DEVICE-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:36 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( diffServActionStorage, diffServAlgDropStatus, diffServAlgDropStorage, diffServAlgDropType, diffServClfrElementStatus, diffServClfrElementStorage, diffServClfrStatus, diffServClfrStorage, diffServCountActStorage, diffServDataPathStatus, diffServDataPathStorage, diffServMIBActionGroup, diffServMIBAlgDropGroup, diffServMIBClfrElementGroup, diffServMIBClfrGroup, diffServMIBCounterGroup, diffServMIBDataPathGroup, diffServMIBDscpMarkActGroup, diffServMIBMultiFieldClfrGroup, diffServMultiFieldClfrAddrType, diffServMultiFieldClfrDstAddr, diffServMultiFieldClfrSrcAddr, diffServMultiFieldClfrStorage, ) = mibBuilder.importSymbols("DIFFSERV-MIB", "diffServActionStorage", "diffServAlgDropStatus", "diffServAlgDropStorage", "diffServAlgDropType", "diffServClfrElementStatus", "diffServClfrElementStorage", "diffServClfrStatus", "diffServClfrStorage", "diffServCountActStorage", "diffServDataPathStatus", "diffServDataPathStorage", "diffServMIBActionGroup", "diffServMIBAlgDropGroup", "diffServMIBClfrElementGroup", "diffServMIBClfrGroup", "diffServMIBCounterGroup", "diffServMIBDataPathGroup", "diffServMIBDscpMarkActGroup", "diffServMIBMultiFieldClfrGroup", "diffServMultiFieldClfrAddrType", "diffServMultiFieldClfrDstAddr", "diffServMultiFieldClfrSrcAddr", "diffServMultiFieldClfrStorage")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( ZeroBasedCounter32, ) = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, mib_2, zeroDotZero, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32", "mib-2", "zeroDotZero")
( DateAndTime, RowPointer, RowStatus, StorageType, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "RowPointer", "RowStatus", "StorageType", "TruthValue")

# Objects

docsDev = ModuleIdentity((1, 3, 6, 1, 2, 1, 69)).setRevisions(("2006-12-20 00:00","1999-08-19 00:00",))
if mibBuilder.loadTexts: docsDev.setOrganization("IETF IP over Cable Data Network\nWorking Group")
if mibBuilder.loadTexts: docsDev.setContactInfo("        Rich Woundy\nPostal: Comcast Cable\n        27 Industrial Avenue\n        Chelmsford, MA 01824 U.S.A.\nPhone:  +1 978 244 4010\nE-mail: richard_woundy@cable.comcast.com\n\n        Kevin Marez\nPostal: Motorola Corporation\n        6450 Sequence Drive\n        San Diego, CA 92121 U.S.A.\nPhone:  +1 858 404 3785\nE-mail: kevin.marez@motorola.com\n\nIETF IPCDN Working Group\nGeneral Discussion: ipcdn@ietf.org\nSubscribe: http://www.ietf.org/mailman/listinfo/ipcdn\nArchive: ftp://ftp.ietf.org/ietf-mail-archive/ipcdn\nCo-chairs: Richard Woundy,\n           richard_woundy@cable.comcast.com\n           Jean-Francois Mule,\n           jf.mule@cablelabs.com")
if mibBuilder.loadTexts: docsDev.setDescription("This is the MIB Module for DOCSIS-compliant cable modems\n\n\n\nand cable-modem termination systems.\n\nCopyright (C) The IETF Trust (2006).  This version\nof this MIB module was published in RFC 4639; for full\nlegal notices see the RFC itself.")
docsDevNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 0))
docsDevMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1))
docsDevBase = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 1))
docsDevRole = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("cm", 1), ("cmtsActive", 2), ("cmtsBackup", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevRole.setDescription("Defines the current role of this device.  cm(1) is a\nCable Modem, cmtsActive(2) is a Cable Modem Termination\nSystem that is controlling the system of cable modems,\nand cmtsBackup(3) is a CMTS that is currently connected\nbut is not controlling the system (not currently used).\n\nIn general, if this device is a 'cm', its role will not\nchange during operation or between reboots.  If the\ndevice is a 'cmts' it may change between cmtsActive and\ncmtsBackup and back again during normal operation.  NB:\nAt this time, the DOCSIS standards do not support the\nconcept of a backup CMTS, but cmtsBackup is included for\ncompleteness.")
docsDevDateTime = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 2), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevDateTime.setDescription("The current date and time, with time zone information\n(if known).\n\nIf the real data and time cannot be determined, this\nshall represent elapsed time from boot relative to\nthe standard epoch '1970-1-1,0:0:0.0'.  In other\nwords, if this agent has been up for 3 minutes and\nnot been able to determine what the actual date and\ntime are, this object will return the value\n'1970-1-1,0:03:0.0'.")
docsDevResetNow = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevResetNow.setDescription("Setting this object to true(1) causes the device to\nreset.  Reading this object always returns false(2).")
docsDevSerialNumber = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 4), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSerialNumber.setDescription("The manufacturer's serial number for this device.")
docsDevSTPControl = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("stEnabled", 1), ("noStFilterBpdu", 2), ("noStPassBpdu", 3), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSTPControl.setDescription("This object controls operation of the spanning tree\nprotocol (as distinguished from transparent bridging).\n\nIf set to stEnabled(1), then the spanning tree protocol\nis enabled, subject to bridging constraints.\n\n\n\nIf noStFilterBpdu(2), then spanning tree is not active,\nand Bridge PDUs received are discarded.\n\nIf noStPassBpdu(3), then spanning tree is not active,\nand Bridge PDUs are transparently forwarded.\n\nNote that a device need not implement all of these\noptions, but that noStFilterBpdu(2) is required.")
docsDevIgmpModeControl = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("passive", 1), ("active", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevIgmpModeControl.setDescription("This object controls the IGMP mode of operation for\nthe CM or CMTS.  In passive mode, the device forwards\nIGMP between interfaces as based on knowledge of\nMulticast Session activity on the subscriber side\ninterface and the rules defined in the DOCSIS RFI\nspecification.  In active mode, the device terminates\nat and initiates IGMP through its interfaces as based\non the knowledge of Multicast Session activity on the\nsubscriber side interface.")
docsDevMaxCpe = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly").setUnits("CPEs")
if mibBuilder.loadTexts: docsDevMaxCpe.setDescription("The maximum number of CPEs that can be granted access\nthrough a CM during a CM epoch.  This value can be\nobtained from the CM configuration file; however,\nit may be adjusted by the CM according to hardware or\nsoftware limitations that have been imposed on the\nimplementation.")
docsDevNmAccessTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 2))
if mibBuilder.loadTexts: docsDevNmAccessTable.setDescription("This table controls access to SNMP objects by network\nmanagement stations.  If the table is empty, access to\nSNMP objects is unrestricted.  The objects in this table\nMUST NOT persist across reboots.  The objects in this\ntable are only accessible from cable devices that are\nnot capable of operating in SNMP Coexistence mode\n(RFC 3584) or in SNMPv3 mode (RFC 3410).\nSee the conformance section for\ndetails.  Note that some devices are required by other\nspecifications (e.g., the DOCSIS OSSIv1.1 specification)\nto support the legacy SNMPv1/v2c docsDevNmAccess mode\nfor backward compatibility.\n\nThis table is deprecated.  Instead, use the SNMP\ncoexistence MIBs from RFC 3584, the TARGET and\nNOTIFICATION MIBs from RFC 3413, and\nthe View-Based Access Control Model (VACM) MIBs for\nall SNMP protocol versions from RFC 3415.")
docsDevNmAccessEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 2, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIndex"))
if mibBuilder.loadTexts: docsDevNmAccessEntry.setDescription("An entry describing access to SNMP objects by a\nparticular network management station.  An entry in\nthis table is not readable unless the management station\nhas read-write permission (either implicit if the table\nis empty, or explicit through an entry in this table).\nEntries are ordered by docsDevNmAccessIndex.  The first\n\n\n\nmatching entry (e.g., matching IP address and community\nstring) is used to derive access.")
docsDevNmAccessIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevNmAccessIndex.setDescription("Index used to order the application of access\nentries.")
docsDevNmAccessIp = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 2), IpAddress().clone("0.0.0.0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessIp.setDescription("The IP address (or subnet) of the network management\nstation.  The address 0.0.0.0 is defined to mean\nany Network Management Station (NMS).  If traps are\nenabled for this entry, then the value must be the\naddress of a specific device.  Implementations MAY\nrecognize 255.255.255.255 as equivalent to 0.0.0.0.")
docsDevNmAccessIpMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 3), IpAddress().clone("0.0.0.0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessIpMask.setDescription("The IP subnet mask of the network management stations.\nIf traps are enabled for this entry, then the value must\nbe 0.0.0.0.  Implementations MAY recognize\n255.255.255.255 as equivalent to 0.0.0.0.")
docsDevNmAccessCommunity = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 4), OctetString().clone('public')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessCommunity.setDescription("The community string to be matched for access by this\nentry.  If set to a zero-length string, then any\ncommunity string will match.  When read, this object\nSHOULD return a zero-length string.")
docsDevNmAccessControl = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,4,3,5,6,)).subtype(namedValues=NamedValues(("none", 1), ("read", 2), ("readWrite", 3), ("roWithTraps", 4), ("rwWithTraps", 5), ("trapsOnly", 6), )).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessControl.setDescription("Specifies the type of access allowed to this NMS.\nSetting this object to none(1) causes the table entry\nto be destroyed.  Read(2) allows access by 'get' and\n'get-next' PDUs.  ReadWrite(3) allows access by 'set' as\nwell.  RoWithtraps(4), rwWithTraps(5), and trapsOnly(6)\ncontrol distribution of Trap PDUs transmitted by this\ndevice.")
docsDevNmAccessInterfaces = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessInterfaces.setDescription("Specifies the set of interfaces from which requests from\nthis NMS will be accepted.  Each octet within\nthe value of this object specifies a set of eight\n\n\n\ninterfaces, the first octet specifying ports 1\nthrough 8, the second octet specifying interfaces 9\nthrough 16, etc.  Within each octet, the most\nsignificant bit represents the lowest numbered\ninterface, and the least significant bit represents the\nhighest numbered interface.  Thus, each interface is\nrepresented by a single bit within the value of this\nobject.  If that bit has a value of '1' then that\ninterface is included in the set.\n\nNote that entries in this table apply only to link-layer\ninterfaces (e.g., Ethernet and CATV MAC).  Bits\nrepresenting upstream and downstream channel interfaces\nMUST NOT be set to '1'.\n\nNote that if bits corresponding to non-existing\ninterfaces are set, the result is implementation\nspecific.\n\nNote that according to the DOCSIS OSSIv1.1\nspecification, when ifIndex '1' is included in the\nset, then this row applies to all CPE\n(customer-facing) interfaces.\n\nThe size of this object is the minimum required to\nrepresent all configured interfaces for this device.")
docsDevNmAccessStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessStatus.setDescription("Controls and reflects the status of rows in this\ntable.  Rows in this table may be created by either the\ncreate-and-go or create-and-wait paradigm.  There is no\nrestriction on changing values in a row of this table\nwhile the row is active.\n\nThe following objects MUST have valid values before this\nobject can be set to active: docsDevNmAccessIp,\ndocsDevNmAccessStatus, docsDevNmAccessIpMask,\ndocsDevNmAccessCommunity, docsDevNmAccessControl, and\ndocsDevNmAccessInterfaces.")
docsDevNmAccessTrapVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 2, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("disableSNMPv2trap", 1), ("enableSNMPv2trap", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevNmAccessTrapVersion.setDescription("Specifies the TRAP version that is sent to this NMS.\nSetting this object to disableSNMPv2trap (1) causes the\ntrap in SNMPv1 format to be sent to a particular NMS.\nSetting this object to enableSNMPv2trap (2) causes the\ntrap in SNMPv2 format be sent to a particular NMS.")
docsDevSoftware = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 3))
docsDevSwServer = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServer.setDescription("The address of the TFTP server used for software\nupgrades.  If the TFTP server is unknown or is a\nnon-IPv4 address, return 0.0.0.0.\n\nThis object is deprecated.  See docsDevSwServerAddress\nfor its replacement.  This object will have its value\nmodified, given a valid SET to docsDevSwServerAddress.")
docsDevSwFilename = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwFilename.setDescription("The filename of the software image to be downloaded via\nTFTP, or the abs_path (as defined in RFC 2616) of the\nsoftware image to be downloaded via HTTP.\n\nUnless set via SNMP, this is the filename or abs_path\nspecified by the provisioning server during the boot\nprocess that corresponds to the software version that\n\n\n\nis desired for this device.\n\nIf unknown, the value of this object is the zero-length\nstring.")
docsDevSwAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("upgradeFromMgt", 1), ("allowProvisioningUpgrade", 2), ("ignoreProvisioningUpgrade", 3), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwAdminStatus.setDescription("If set to upgradeFromMgt(1), the device will initiate a\nTFTP or HTTP software image download.  After\nsuccessfully receiving an image, the device will set\nits state to ignoreProvisioningUpgrade(3) and reboot.\nIf the download process is interrupted (e.g., by a reset\nor power failure), the device will load the previous\nimage and, after re-initialization, continue to attempt\nloading the image specified in docsDevSwFilename.\n\nIf set to allowProvisioningUpgrade(2), the device will\nuse the software version information supplied by the\nprovisioning server when next rebooting (this does not\ncause a reboot).\n\nWhen set to ignoreProvisioningUpgrade(3), the device\nwill disregard software image upgrade information\nfrom the provisioning server.\n\nNote that reading this object can return\nupgradeFromMgt(1).  This indicates that a software\ndownload is currently in progress, and that the device\nwill reboot after successfully receiving an image.")
docsDevSwOperStatus = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,4,5,1,)).subtype(namedValues=NamedValues(("inProgress", 1), ("completeFromProvisioning", 2), ("completeFromMgt", 3), ("failed", 4), ("other", 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSwOperStatus.setDescription("InProgress(1) indicates that a TFTP or HTTP download is\nunderway, either as a result of a version mismatch at\nprovisioning or as a result of a upgradeFromMgt request.\nNo other docsDevSw* objects can be modified in\nthis state.\n\nCompleteFromProvisioning(2) indicates that the last\nsoftware upgrade was a result of version mismatch at\nprovisioning.\n\nCompleteFromMgt(3) indicates that the last software\nupgrade was a result of setting docsDevSwAdminStatus to\nupgradeFromMgt.\n\nFailed(4) indicates that the last attempted download\nfailed, ordinarily due to TFTP or HTTP timeout.")
docsDevSwCurrentVers = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevSwCurrentVers.setDescription("The software version currently operating in this device.\nThis string's syntax is that used by the\nindividual vendor to identify software versions.\nFor a CM, this string will describe the current\nsoftware load.  For a CMTS, this object SHOULD contain\na human-readable representation either of the vendor\nspecific designation of the software for the chassis,\nor of the software for the control processor.  If\nneither of these is applicable, the value MUST be a\nzero-length string.")
docsDevSwServerAddressType = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 6), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServerAddressType.setDescription("The type of address of the TFTP or HTTP server used for\n\n\n\nsoftware upgrades.\n\nIf docsDevSwServerTransportProtocol is currently set to\ntftp(1), attempting to set this object to dns(16) MUST\nresult in an error.")
docsDevSwServerAddress = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 7), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServerAddress.setDescription("The address of the TFTP or HTTP server used for software\nupgrades.\n\nIf the TFTP/HTTP server is unknown, return the zero-\nlength address string (see the TextualConvention).\n\nIf docsDevSwServer is also implemented in this agent,\nthis object is tied to it.  A set of this object to an\nIPv4 address will result in also setting the value of\ndocsDevSwServer to that address.  If this object is set\nto an IPv6 address, docsDevSwServer is set to 0.0.0.0.\nIf docsDevSwServer is set, this object is also set to\nthat value.  Note that if both are set in the same\naction, the order of which one sets the other is\nundefined.")
docsDevSwServerTransportProtocol = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 3, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("tftp", 1), ("http", 2), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevSwServerTransportProtocol.setDescription("This object specifies the transport protocol (TFTP or\nHTTP) to be used for software upgrades.\n\nIf the value of this object is tftp(1), then the cable\ndevice uses TFTP (RFC 1350) read request packets to\ndownload the docsDevSwFilename from the\ndocsDevSwServerAddress in octet mode.\n\nIf the value of this object is http(2), then the cable\ndevice uses HTTP 1.0 (RFC 1945) or HTTP 1.1 (RFC 2616)\nGET requests sent to host docsDevSwServerAddress to\n\n\n\ndownload the software image from path docsDevSwFilename.\n\nIf docsDevSwServerAddressType is currently set to\ndns(16), attempting to set this object to tftp(1) MUST\nresult in an error.")
docsDevServer = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 4))
docsDevServerBootState = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(3,7,5,6,2,8,10,1,9,4,)).subtype(namedValues=NamedValues(("operational", 1), ("unknown", 10), ("disabled", 2), ("waitingForDhcpOffer", 3), ("waitingForDhcpResponse", 4), ("waitingForTimeServer", 5), ("waitingForTftp", 6), ("refusedByCmts", 7), ("forwardingDenied", 8), ("other", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerBootState.setDescription("If operational(1), the device has completed loading and\nprocessing of configuration parameters, and the CMTS has\ncompleted the Registration exchange.\n\nIf disabled(2), then the device was administratively\ndisabled, possibly by being refused network access in\nthe configuration file.\n\nIf waitingForDhcpOffer(3), then a Dynamic Host\nConfiguration Protocol (DHCP) Discover has been\ntransmitted, and no offer has yet been received.\n\nIf waitingForDhcpResponse(4), then a DHCP Request has\nbeen transmitted, and no response has yet been received.\n\nIf waitingForTimeServer(5), then a Time Request has been\ntransmitted, and no response has yet been received.\n\n\n\nIf waitingForTftp(6), then a request to the TFTP\nparameter server has been made, and no response\nreceived.\n\nIf refusedByCmts(7), then the Registration\nRequest/Response exchange with the CMTS failed.\n\nIf forwardingDenied(8), then the registration process\nwas completed, but the network access option in the\nreceived configuration file prohibits forwarding.\n\nIf other(9), then the registration process reached a\npoint that does not fall into one of the above\ncategories.\n\nIf unknown(10), then the device has not yet begun the\nregistration process or is in some other indeterminate\nstate.")
docsDevServerDhcp = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerDhcp.setDescription("The IP address of the DHCP server that assigned an IP\naddress to this device.  Returns 0.0.0.0 if DHCP is not\nused for IP address assignment, or if this agent is\nnot assigned an IPv4 address.\n\nThis object is deprecated and is replaced by\ndocsDevServerDhcpAddress.")
docsDevServerTime = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTime.setDescription("The IP address of the Time server (RFC 0868).  Returns\n0.0.0.0 if the time server IP address is unknown, or if\nthe time server is not an IPv4 server.\n\nThis object is deprecated and is replaced by\n\n\n\ndocsDevServerTimeAddress.")
docsDevServerTftp = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTftp.setDescription("The IP address of the TFTP server responsible for\ndownloading provisioning and configuration parameters\nto this device.  Returns 0.0.0.0 if the TFTP server\naddress is unknown or is not an IPv4 address.\n\nThis object is deprecated and is replaced by\ndocsDevServerConfigTftpAddress.")
docsDevServerConfigFile = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 5), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerConfigFile.setDescription("The name of the device configuration file read from\nthe TFTP server.  Returns a zero-length string if\nthe configuration file name is unknown.")
docsDevServerDhcpAddressType = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerDhcpAddressType.setDescription("The type of address of docsDevServerDhcpAddress.  If\nDHCP was not used, this value should return\nunknown(0).")
docsDevServerDhcpAddress = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerDhcpAddress.setDescription("The internet address of the DHCP server that assigned\nan IP address to this device.  Returns the zero length\noctet string if DHCP was not used for IP address\nassignment.")
docsDevServerTimeAddressType = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTimeAddressType.setDescription("The type of address of docsDevServerTimeAddress.  If\nno time server exists, this value should return\nunknown(0).")
docsDevServerTimeAddress = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerTimeAddress.setDescription("The Internet address of the RFC 868 Time server,\nas provided by DHCP option 4.\n\nNote that if multiple values are provided to the\nCM in DHCP option 4, the value of this MIB object\nMUST be the Time server address from which the Time\nof Day reference was acquired as based on the DOCSIS\nRFI specification.  During the period of time where\nthe Time of Day have not been acquired, the Time\nserver address reported by the CM may report the\nfirst address value in the DHCP option value or the\nlast server address the CM attempted to get the Time\nof day value.\n\nReturns the zero-length octet string if the time server\nIP address is not provisioned.")
docsDevServerConfigTftpAddressType = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerConfigTftpAddressType.setDescription("The type of address of docsDevServerConfigTftpAddress.\nIf no TFTP server exists, this value should return\nunknown(0).")
docsDevServerConfigTftpAddress = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 4, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevServerConfigTftpAddress.setDescription("The internet address of the TFTP server responsible for\ndownloading provisioning and configuration parameters\nto this device.  Returns the zero-length octet string if\nthe config server address is unknown.  There are certain\nsecurity risks that are involved with using TFTP.")
docsDevEvent = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 5))
docsDevEvControl = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("resetLog", 1), ("useDefaultReporting", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvControl.setDescription("Setting this object to resetLog(1) empties the event\nlog.  All data is deleted.  Setting it to\nuseDefaultReporting(2) returns all event priorities to\ntheir factory-default reporting.  Reading this object\nalways returns useDefaultReporting(2).")
docsDevEvSyslog = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvSyslog.setDescription("The IP address of the Syslog server.  If 0.0.0.0, either\nsyslog transmission is inhibited, or the Syslog server\naddress is not an IPv4 address.\n\nThis object is deprecated and is replaced by\ndocsDevEvSyslogAddress.")
docsDevEvThrottleAdminStatus = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,4,)).subtype(namedValues=NamedValues(("unconstrained", 1), ("maintainBelowThreshold", 2), ("stopAtThreshold", 3), ("inhibited", 4), )).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvThrottleAdminStatus.setDescription("Controls the transmission of traps and syslog messages\nwith respect to the trap pacing threshold.\n\nunconstrained(1) causes traps and syslog messages to be\ntransmitted without regard to the threshold settings.\n\nmaintainBelowThreshold(2) causes trap transmission and\nsyslog messages to be suppressed if the number of traps\nwould otherwise exceed the threshold.\n\nstopAtThreshold(3) causes trap transmission to cease at\nthe threshold and not to resume until directed to do so.\n\ninhibited(4) causes all trap transmission and syslog\nmessages to be suppressed.\n\nA single event is always treated as a single event for\nthreshold counting.  That is, an event causing both a\ntrap and a syslog message is still treated as a single\nevent.\n\nWriting to this object resets the thresholding state.")
docsDevEvThrottleInhibited = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvThrottleInhibited.setDescription("If true(1), trap and syslog transmission is currently\ninhibited due to thresholds and/or the current setting\nof docsDevEvThrottleAdminStatus.  In addition, this is\ntrue(1) when transmission is inhibited because no\nsyslog (docsDevEvSyslog) or trap (docsDevNmAccessEntry)\ndestinations have been set.\n\nThis object is deprecated and is replaced by\ndocsDevEvThrottleThresholdExceeded.")
docsDevEvThrottleThreshold = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 5), Unsigned32().clone(0)).setMaxAccess("readwrite").setUnits("events")
if mibBuilder.loadTexts: docsDevEvThrottleThreshold.setDescription("Number of events per docsDevEvThrottleInterval permitted\nbefore throttling is to occur.\n\nA single event, whether the notification could result in\nmessages transmitted using syslog, SNMP, or both\nprotocols, and regardless of the number of destinations,\n(including zero) is always treated as a single event for\nthreshold counting.  For example, an event causing both\na trap and a syslog message is still treated as a single\nevent.\n\nAll system notifications that occur within the device\nshould be taken into consideration when calculating\nand monitoring the threshold.")
docsDevEvThrottleInterval = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: docsDevEvThrottleInterval.setDescription("The interval over which docsDevEvThrottleThreshold\napplies.")
docsDevEvControlTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 5, 7))
if mibBuilder.loadTexts: docsDevEvControlTable.setDescription("This table allows control of the reporting of event\nclasses.  For each event priority, a combination of\n\n\n\nlogging and reporting mechanisms may be chosen.  The\nmapping of event types to priorities is\nvendor dependent.  Vendors may also choose to allow\nthe user to control that mapping through proprietary\nmeans.  Table entries MUST persist across reboots for\nCMTS devices and MUST NOT persist across reboots for CM\ndevices.")
docsDevEvControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 5, 7, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevEvPriority"))
if mibBuilder.loadTexts: docsDevEvControlEntry.setDescription("Allows configuration of the reporting mechanisms for a\nparticular event priority.")
docsDevEvPriority = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 7, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(7,6,3,1,8,4,5,2,)).subtype(namedValues=NamedValues(("emergency", 1), ("alert", 2), ("critical", 3), ("error", 4), ("warning", 5), ("notice", 6), ("information", 7), ("debug", 8), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevEvPriority.setDescription("The priority level that is controlled by this\nentry.  These are ordered from most (emergency) to least\n(debug) critical.  Each event with a CM or CMTS has a\nparticular priority level associated with it (as defined\nby the vendor).\n\nemergency(1) events indicate vendor-specific fatal\nhardware or software errors that prevent normal system\noperation.\n\n\n\n\nalert(2) events indicate a serious failure that causes\nthe reporting system to reboot but is not caused by\nhardware or software malfunctioning.\n\ncritical(3) events indicate a serious failure that\nrequires attention and prevents the device from\ntransmitting data but that could be recovered without\nrebooting the system.\n\nerror(4) and warning(5) events indicate that a failure\noccurred that could interrupt the normal data flow but\nthat does not cause the device to re-register.\n\nnotice(6) and information(7) events indicate a\nmilestone or checkpoint in normal operation that could\nbe of particular importance for troubleshooting.\n\ndebug(8) events are reserved for vendor-specific\nevents.\n\nDuring normal operation, no event more\ncritical than notice(6) should be generated.  Events\nbetween warning and emergency should be generated at\nappropriate levels of problems (e.g., emergency when the\nbox is about to crash).")
docsDevEvReporting = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 7, 1, 2), Bits().subtype(namedValues=NamedValues(("local", 0), ("traps", 1), ("syslog", 2), ("localVolatile", 8), ("stdInterface", 9), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvReporting.setDescription("Defines the action to be taken on occurrence of this\nevent class.  Implementations may not necessarily\nsupport all options for all event classes but at\nminimum must allow traps and syslogging to be\ndisabled.\n\n\n\n\nIf the local(0) bit is set, then log to the internal\nlog and update non-volatile store, for backward\ncompatibility with the original RFC 2669 definition.\nIf the traps(1) bit is set, then generate\nan SNMP trap; if the syslog(2) bit is set, then\nsend a syslog message (assuming that the syslog address\nis set).  If the localVolatile(8) bit is set, then\nlog to the internal log without updating non-volatile\nstore.  If the stdInterface(9) bit is set, then the\nagent ignores all other bits except the local(0),\nsyslog(2), and localVolatile(8) bits.  Setting the\nstdInterface(9) bit indicates that RFC3413 and\nRFC3014 are being used to control event reporting\nmechanisms.")
docsDevEventTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 5, 8))
if mibBuilder.loadTexts: docsDevEventTable.setDescription("Contains a log of network and device events that may be\nof interest in fault isolation and troubleshooting.\nIf the local(0) bit is set in docsDevEvReporting,\nentries in this table MUST persist across reboots.")
docsDevEventEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevEvIndex"))
if mibBuilder.loadTexts: docsDevEventEntry.setDescription("Describes a network or device event that may be of\ninterest in fault isolation and troubleshooting.\nMultiple sequential identical events are represented by\nincrementing docsDevEvCounts and setting\ndocsDevEvLastTime to the current time rather than\ncreating multiple rows.\n\nEntries are created with the first occurrence of an\nevent.  docsDevEvControl can be used to clear the\ntable.  Individual events cannot be deleted.")
docsDevEvIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevEvIndex.setDescription("Provides relative ordering of the objects in the event\nlog.  This object will always increase except when\n(a) the log is reset via docsDevEvControl,\n(b) the device reboots and does not implement\nnon-volatile storage for this log, or (c) it reaches\nthe value 2^31.  The next entry for all the above\ncases is 1.")
docsDevEvFirstTime = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 2), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvFirstTime.setDescription("The value of docsDevDateTime at the time this entry was\ncreated.")
docsDevEvLastTime = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvLastTime.setDescription("When an entry reports only one event, this object will\nhave the same value as the corresponding instance of\ndocsDevEvFirstTime.  When an entry reports multiple\nevents, this object will record the value that\ndocsDevDateTime had when the most recent event for this\nentry occurred.")
docsDevEvCounts = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvCounts.setDescription("The number of consecutive event instances reported by\nthis entry.  This starts at 1 with the creation of this\nrow and increments by 1 for each subsequent duplicate\nevent.")
docsDevEvLevel = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(7,6,3,1,8,4,5,2,)).subtype(namedValues=NamedValues(("emergency", 1), ("alert", 2), ("critical", 3), ("error", 4), ("warning", 5), ("notice", 6), ("information", 7), ("debug", 8), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvLevel.setDescription("The priority level of this event, as defined by the\nvendor.  These are ordered from most serious (emergency)\nto least serious (debug).\n\nemergency(1) events indicate vendor-specific fatal\nhardware or software errors that prevent normal system\noperation.\n\nalert(2) events indicate a serious failure that causes\nthe reporting system to reboot but that is not caused by\nhardware or software malfunctioning.\n\ncritical(3) events indicate a serious failure that\nrequires attention and prevents the device from\ntransmitting data but that could be recovered without\nrebooting the system.\n\nerror(4) and warning(5) events indicate that a failure\noccurred that could interrupt the normal data flow but\nthat does not cause the device to re-register.\n\nnotice(6) and information(7) events indicate a\nmilestone or checkpoint in normal operation that could\nbe of particular importance for troubleshooting.\n\ndebug(8) events are reserved for vendor-specific\n\n\n\nevents.\n\nDuring normal operation, no event more\ncritical than notice(6) should be generated.  Events\nbetween warning and emergency should be generated at\nappropriate levels of problems (e.g., emergency when the\nbox is about to crash).")
docsDevEvId = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvId.setDescription("For this product, uniquely identifies the type of event\nthat is reported by this entry.")
docsDevEvText = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 5, 8, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvText.setDescription("Provides a human-readable description of the event,\nincluding all relevant context (interface numbers,\netc.).")
docsDevEvSyslogAddressType = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 9), InetAddressType().clone('unknown')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvSyslogAddressType.setDescription("The type of address of docsDevEvSyslogAddress.  If\nno syslog server exists, this value should return\nunknown(0).")
docsDevEvSyslogAddress = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 10), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevEvSyslogAddress.setDescription("The Internet address of the Syslog server, as provided\nby DHCP option 7 or set via SNMP management.  If the\naddress of the server is set to the zero-length\nstring, the 0.0.0.0 IPv4 address, or the 0: IPv6\naddress, Syslog transmission is inhibited.\n\nNote that if multiple values are provided to the CM in\nDHCP option 7, the value of this MIB object MUST be the\nfirst Syslog server address received.\n\nBy default at agent boot, this object returns the zero\nlength string.")
docsDevEvThrottleThresholdExceeded = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 5, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevEvThrottleThresholdExceeded.setDescription("If true(1), trap and syslog transmission is currently\ninhibited due to exceeding the trap/syslog event\nthreshold in the current interval.")
docsDevFilter = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 6))
docsDevFilterLLCUnmatchedAction = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 6, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("discard", 1), ("accept", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevFilterLLCUnmatchedAction.setDescription("LLC (Link Level Control) filters can be defined on an\ninclusive or exclusive basis: CMs can be configured to\nforward only packets matching a set of layer three\nprotocols, or to drop packets matching a set of layer\nthree protocols.  Typical use of these filters is to\n\n\n\nfilter out possibly harmful (given the context of a\nlarge metropolitan LAN) protocols.\n\nIf set to discard(1), any L2 packet that does not match\nat least one filter in the docsDevFilterLLCTable will be\ndiscarded.  If set to accept(2), any L2 packet that\ndoes not match at least one filter in the\ndocsDevFilterLLCTable will be accepted for further\nprocessing (e.g., bridging).  In other words, if the\npacket does not match an entry in the table, it takes\nthis action; if it does match an entry in the table, it\ntakes the opposite of this action.")
docsDevFilterLLCTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 2))
if mibBuilder.loadTexts: docsDevFilterLLCTable.setDescription("A list of filters to apply to (bridged) LLC\ntraffic.  The filters in this table are applied to\nincoming traffic on the appropriate interface(s)  prior\nto any further processing (e.g., before the packet\nis handed off for level 3 processing, or for bridging).\nThe specific action taken when no filter is matched is\ncontrolled by docsDevFilterLLCUnmatchedAction.  Table\nentries MUST NOT persist across reboots for any device.")
docsDevFilterLLCEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIndex"))
if mibBuilder.loadTexts: docsDevFilterLLCEntry.setDescription("Describes a single filter to apply to (bridged) LLC\ntraffic received on a specified interface. ")
docsDevFilterLLCIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevFilterLLCIndex.setDescription("Index used for the identification of filters (note that\nLLC filter order is irrelevant).")
docsDevFilterLLCStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCStatus.setDescription("Controls and reflects the status of rows in this\ntable.  There is no restriction on changing any of the\nassociated columns for this row while this object is set\nto active.\n\nSpecifying only this object (with the\nappropriate index) on a CM is sufficient to create a\nfilter row that matches all inbound packets on the\nethernet interface and results in the packets being\ndiscarded.  docsDevFilterLLCIfIndex (at least) must be\nspecified on a CMTS to create a row.")
docsDevFilterLLCIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCIfIndex.setDescription("The entry interface to which this filter applies.  The\nvalue corresponds to ifIndex for either a CATV MAC or\nanother network interface.  If the value is zero, the\nfilter applies to all interfaces.  In Cable Modems, the\ndefault value is the customer side interface(s).  In\nCMTSs, this object has to be specified to\ncreate a row in this table.\n\nNote that according to the DOCSIS OSSIv1.1\nspecification, ifIndex '1' in the CM means that this\nrow applies to all Cable Modem-to-CPE Interfaces\n(CMCI).")
docsDevFilterLLCProtocolType = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("ethertype", 1), ("dsap", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCProtocolType.setDescription("The format of the value in docsDevFilterLLCProtocol:\neither a two-byte Ethernet Ethertype, or a one-byte\n802.2 Service Access Point (SAP) value.  ethertype(1)\nalso applies to Standard Network Access Protocol\n(SNAP) encapsulated frames.")
docsDevFilterLLCProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterLLCProtocol.setDescription("The layer-three protocol for which this filter applies.\nThe protocol value format depends on\ndocsDevFilterLLCProtocolType.  Note that for SNAP\nframes, ethertype filtering is performed rather than\nDestination Service Access Point (DSAP) =0xAA.")
docsDevFilterLLCMatches = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevFilterLLCMatches.setDescription("Counts the number of times this filter was matched.")
docsDevFilterIpDefault = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 6, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("discard", 1), ("accept", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevFilterIpDefault.setDescription("The default behavior for (bridged) packets that do not\nmatch IP filters (or Internet filters, if implemented)\nis defined by docsDevFilterIpDefault.\n\nIf set to discard(1), all packets not matching an IP\nfilter in docsDevFilterIpTable will be discarded.  If\nset to accept(2), all packets not matching an IP filter\nor an Internet filter will be accepted for further\nprocessing (e.g., bridging).")
docsDevFilterIpTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 4))
if mibBuilder.loadTexts: docsDevFilterIpTable.setDescription("An ordered list of filters or classifiers to apply to\nIP traffic.  Filter application is ordered by the filter\nindex, rather than by a best match algorithm (note that\nthis implies that the filter table may have gaps in the\nindex values).  Packets that match no filters will have\npolicy 0 in the docsDevFilterPolicyTable applied to\nthem, if it exists.  Otherwise, Packets that match no\nfilters are discarded or forwarded according to the\nsetting of docsDevFilterIpDefault.\n\nAny IP packet can theoretically match multiple rows of\nthis table.  When considering a packet, the table is\nscanned in row index order (e.g., filter 10 is checked\nbefore filter 20).  If the packet matches that filter\n(which means that it matches ALL criteria for that row),\nactions appropriate to docsDevFilterIpControl and\ndocsDevFilterPolicyId are taken.  If the packet was\ndiscarded processing is complete.  If\ndocsDevFilterIpContinue is set to true, the filter\ncomparison continues with the next row in the table,\nlooking for additional matches.\n\nIf the packet matches no filter in the table, the packet\nis accepted or dropped for further processing\naccording to the setting of docsDevFilterIpDefault.\nIf the packet is accepted, the actions specified by\npolicy group 0 (e.g., the rows in\ndocsDevFilterPolicyTable that have a value of 0 for\ndocsDevFilterPolicyId) are taken, if that policy\n\n\n\ngroup exists.\n\nLogically, this table is consulted twice during the\nprocessing of any IP packet: once upon its acceptance\nfrom the L2 entity, and once upon its transmission to\nthe L2 entity.  In actuality, for cable modems, IP\nfiltering is generally the only IP processing done for\ntransit traffic.  This means that inbound and outbound\nfiltering can generally be done at the same time with\none pass through the filter table.\n\nThe objects in this table are only accessible from cable\ndevices that are not operating in DiffServ MIB mode\n(RFC 3289).  See the conformance section for details.\n\nNote that some devices are required by other\nspecifications (e.g., the DOCSIS OSSIv1.1 specification)\nto support the legacy SNMPv1/v2c docsDevFilter mode\nfor backward compatibility.\n\nTable entries MUST NOT persist across reboots for any\ndevice.\n\nThis table is deprecated.  Instead, use the DiffServ MIB\nfrom RFC 3289.")
docsDevFilterIpEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpIndex"))
if mibBuilder.loadTexts: docsDevFilterIpEntry.setDescription("Describes a filter to apply to IP traffic received on a\nspecified interface.  All identity objects in this table\n(e.g., source and destination address/mask, protocol,\nsource/dest port, TOS/mask, interface and direction)\nmust match their respective fields in the packet for\nany given filter to match.\n\nTo create an entry in this table, docsDevFilterIpIfIndex\nmust be specified.")
docsDevFilterIpIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevFilterIpIndex.setDescription("Index used to order the application of filters.\nThe filter with the lowest index is always applied\nfirst.")
docsDevFilterIpStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpStatus.setDescription("Controls and reflects the status of rows in this\ntable.  Specifying only this object (with the\nappropriate index) on a CM is sufficient to create a\nfilter row that matches all inbound packets on the\nethernet interface and results in the packets being\ndiscarded.  docsDevFilterIpIfIndex (at least) must be\nspecified on a CMTS to create a row.  Creation of the\nrows may be done via either create-and-wait or\ncreate-and-go, but the filter is not applied until this\nobject is set to (or changes to) active.  There is no\nrestriction in changing any object in a row while this\nobject is set to active.")
docsDevFilterIpControl = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("discard", 1), ("accept", 2), ("policy", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpControl.setDescription("If set to discard(1), all packets matching this filter\nwill be discarded, and scanning of the remainder of the\nfilter list will be aborted.  If set to accept(2), all\npackets matching this filter will be accepted for\nfurther processing (e.g., bridging).  If\ndocsDevFilterIpContinue is set to true, see if there\nare other matches; otherwise, done.  If set to\npolicy (3), execute the policy entries\nmatched by docsDevFilterIpPolicyId in\ndocsDevFilterPolicyTable.\n\nIf docsDevFilterIpContinue is set to true, continue\nscanning the table for other matches; otherwise, done.")
docsDevFilterIpIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpIfIndex.setDescription("The entry interface to which this filter applies.  The\nvalue corresponds to ifIndex for either a CATV MAC or\nanother interface.  If the value is zero, the\nfilter applies to all interfaces.  Default value in CMs\nis the index of the customer-side (e.g., ethernet)\ninterface(s).  In CMTSes, this object MUST be\nspecified to create a row in this table.\n\nNote that according to the DOCSIS OSSIv1.1\nspecification, ifIndex '1' in the Cable Modem means\nthat this row applies to all CMCI (customer-facing)\ninterfaces.")
docsDevFilterIpDirection = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("inbound", 1), ("outbound", 2), ("both", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDirection.setDescription("Determines whether the filter is applied to inbound(1)\ntraffic, outbound(2) traffic, or traffic in both(3)\ndirections.")
docsDevFilterIpBroadcast = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpBroadcast.setDescription("If set to true(1), the filter only applies to multicast\nand broadcast traffic.  If set to false(2), the filter\napplies to all traffic.")
docsDevFilterIpSaddr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 7), IpAddress().clone("0.0.0.0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSaddr.setDescription("The source IP address, or portion thereof, that is to be\nmatched for this filter.  The source address is first\nmasked (ANDed) against docsDevFilterIpSmask before\nbeing compared to this value.  A value of 0 for this\nobject and 0 for the mask matches all IP addresses.")
docsDevFilterIpSmask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 8), IpAddress().clone("0.0.0.0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSmask.setDescription("A bit mask that is to be applied to the source address\nprior to matching.  This mask is not necessarily the\nsame as a subnet mask, but 1s bits must be leftmost and\ncontiguous.")
docsDevFilterIpDaddr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 9), IpAddress().clone("0.0.0.0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDaddr.setDescription("The destination IP address, or portion thereof, that is\nto be matched for this filter.  The destination address\nis first masked (ANDed) against docsDevFilterIpDmask\nbefore being compared to this value.  A value of\n00000000 for this object and 00000000 for the mask\nmatches all IP addresses.")
docsDevFilterIpDmask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 10), IpAddress().clone("0.0.0.0")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDmask.setDescription("A bit mask that is to be applied to the destination\naddress prior to matching.  This mask is not necessarily\nthe same as a subnet mask, but 1s bits MUST be leftmost\nand contiguous.")
docsDevFilterIpProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256)).clone(256)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpProtocol.setDescription("The IP protocol value that is to be matched.  For\nexample, icmp is 1, tcp is 6, and udp is 17.  A value of\n256 matches ANY protocol.")
docsDevFilterIpSourcePortLow = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSourcePortLow.setDescription("This is the inclusive lower bound of the transport-layer\nsource port range that is to be matched.  If the IP\nprotocol of the packet is neither UDP nor TCP, this\n\n\n\nobject is ignored during matching.")
docsDevFilterIpSourcePortHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpSourcePortHigh.setDescription("This is the inclusive upper bound of the transport-layer\nsource port range that is to be matched.  If the IP\nprotocol of the packet is neither UDP nor TCP, this\nobject is ignored during matching.")
docsDevFilterIpDestPortLow = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDestPortLow.setDescription("This is the inclusive lower bound of the transport-layer\ndestination port range that is to be matched.  If the IP\nprotocol of the packet is neither UDP nor TCP, this\nobject is ignored during matching.")
docsDevFilterIpDestPortHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpDestPortHigh.setDescription("This is the inclusive upper bound of the transport-layer\ndestination port range that is to be matched.  If the IP\nprotocol of the packet is neither UDP nor TCP, this\nobject is ignored during matching.")
docsDevFilterIpMatches = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 16), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevFilterIpMatches.setDescription("Counts the number of times this filter was matched.\nThis object is initialized to 0 at boot, or at row\ncreation, and is reset only upon reboot.")
docsDevFilterIpTos = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue='00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpTos.setDescription("This is the value to be matched to the packet's\nTOS (Type of Service) value (after the TOS value\nis ANDed with docsDevFilterIpTosMask).  A value for this\nobject of 0 and a mask of 0 matches all TOS values.")
docsDevFilterIpTosMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue='00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpTosMask.setDescription("The mask to be applied to the packet's TOS value before\nmatching.")
docsDevFilterIpContinue = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 19), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpContinue.setDescription("If this value is set to true and docsDevFilterIpControl\nis anything but discard (1), continue scanning and\napplying policies.  See Section 3.3.3 for more\ndetails.")
docsDevFilterIpPolicyId = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 4, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterIpPolicyId.setDescription("This object points to an entry in\ndocsDevFilterPolicyTable.  If docsDevFilterIpControl\n\n\n\nis set to policy (3), execute all matching policies\nin docsDevFilterPolicyTable.  If no matching policy\nexists, treat as if docsDevFilterIpControl were set\nto accept (1).  If this object is set to the value of\n0, there is no matching policy, and\ndocsDevFilterPolicyTable MUST NOT be consulted.")
docsDevFilterPolicyTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 5))
if mibBuilder.loadTexts: docsDevFilterPolicyTable.setDescription("A Table that maps between a policy group ID and a set\nof pointers to policies to be applied.  All rows with\nthe same docsDevFilterPolicyId are part of the same\ngroup of policy pointers and are applied in the order\nin this table.  docsDevFilterPolicyTable exists to\nallow multiple policy actions (referenced by policy\npointers) to be applied to any given classified packet.\nThe policy actions are applied in index order.\nFor example:\n\nIndex   ID    Type    Action\n 1      1      TOS     1\n 9      5      TOS     1\n 12     1      IPSEC   3\n\nThis says that a packet that matches a filter with\npolicy id 1 first has TOS policy 1 applied (which might\nset the TOS bits to enable a higher priority) and next\nhas the IPSEC policy 3 applied (which may result in the\npackets being dumped into a secure VPN to a remote\nencryptor).\n\nPolicy ID 0 is reserved for default actions and is\napplied only to packets that match no filters in\ndocsDevFilterIpTable.\n\nTable entries MUST NOT persist across reboots for any\ndevice.\n\nThis table is deprecated.  Instead, use the DiffServ MIB\n\n\n\nfrom RFC 3289.")
docsDevFilterPolicyEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyIndex"))
if mibBuilder.loadTexts: docsDevFilterPolicyEntry.setDescription("An entry in the docsDevFilterPolicyTable.  Entries are\ncreated by Network Management.  To create an entry,\ndocsDevFilterPolicyId MUST be specified.")
docsDevFilterPolicyIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevFilterPolicyIndex.setDescription("Index value for the table.")
docsDevFilterPolicyId = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyId.setDescription("Policy ID for this entry.  If a policy ID can apply to\nmultiple rows of this table, all relevant policies are\nexecuted.  Policy 0 (if populated) is applied to all\npackets that do not match any of the filters.  N.B. If\ndocsDevFilterIpPolicyId is set to 0, it DOES NOT match\npolicy 0 of this table.")
docsDevFilterPolicyStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyStatus.setDescription("Object used to create an entry in this table.  There is\nno restriction in changing any object in a row while\nthis object is set to active.\nThe following object MUST have a valid value before this\nobject can be set to active:  docsDevFilterPolicyPtr.")
docsDevFilterPolicyPtr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 5, 1, 6), RowPointer().clone('0.0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterPolicyPtr.setDescription("This object points to a row in an applicable filter\npolicy table.  Currently, the only standard policy\ntable is docsDevFilterTosTable.\n\nPer the textual convention, this object points to the\nfirst accessible object in the row; e.g., to point to a\nrow in docsDevFilterTosTable with an index of 21, the\nvalue of this object would be the object identifier\ndocsDevTosStatus.21.\n\nVendors are recommended to adhere to the same convention\nwhen adding vendor-specific policy table extensions.\n\nIf this pointer references an empty or non-existent\nrow, then no policy action is taken.\n\nThe default upon row creation is a null pointer that\nresults in no policy action being taken.")
docsDevFilterTosTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 6, 6))
if mibBuilder.loadTexts: docsDevFilterTosTable.setDescription("Table used to describe Type of Service (TOS) bits\n\n\n\nprocessing.\n\nThis table is an adjunct to the docsDevFilterIpTable\nand the docsDevFilterPolicy table.  Entries in the\nlatter table can point to specific rows in this (and\nother) tables and cause specific actions to be taken.\nThis table permits the manipulation of the value of the\nType of Service bits in the IP header of the matched\npacket as follows:\n\nSet the tosBits of the packet to\n   (tosBits & docsDevFilterTosAndMask) |\n   docsDevFilterTosOrMask\n\nThis construct allows you to do a clear and set of all\nthe TOS bits in a flexible manner.\n\nTable entries MUST NOT persist across reboots for any\ndevice.\n\nThis table is deprecated.  Instead, use the DiffServ MIB\nfrom RFC 3289.")
docsDevFilterTosEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosIndex"))
if mibBuilder.loadTexts: docsDevFilterTosEntry.setDescription("A TOS policy entry.")
docsDevFilterTosIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevFilterTosIndex.setDescription("The unique index for this row.  There are no ordering\nrequirements for this table, and any valid index may be\nspecified.")
docsDevFilterTosStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosStatus.setDescription("The object used to create and delete entries in this\ntable.  A row created by specifying just this object\nresults in a row that specifies no change to the TOS\nbits.  A row may be created using either the\ncreate-and-go or create-and-wait paradigms.  There is\nno restriction on the ability to change values in this\nrow while the row is active.")
docsDevFilterTosAndMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue='ff')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosAndMask.setDescription("This value is bitwise ANDed with the matched packet's\nTOS bits.")
docsDevFilterTosOrMask = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 6, 6, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue='00')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevFilterTosOrMask.setDescription("This value is bitwise ORed with the result from the\nAND procedure (tosBits & docsDevFilterTosAndMask).\nThe result then replaces the packet's TOS bits.")
docsDevCpe = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 1, 7))
docsDevCpeEnroll = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 7, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("none", 1), ("any", 2), )).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevCpeEnroll.setDescription("This object controls the population of\ndocsDevFilterCpeTable.\nIf set to none, the filters must be set manually\nby a network management action (either configuration\nor SNMP set).\nIf set to any, the CM wiretaps the packets originating\nfrom the ethernet and enrolls up to docsDevCpeIpMax\naddresses as based on the source IPv4 or v6 addresses of\nthose packets.")
docsDevCpeIpMax = MibScalar((1, 3, 6, 1, 2, 1, 69, 1, 7, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: docsDevCpeIpMax.setDescription("This object controls the maximum number of CPEs allowed\nto be learned behind this device.  If set to zero, any\nnumber of CPEs may connect up to the maximum permitted\nfor the device.\nIf set to -1, no filtering is done on CPE source\naddresses, and no entries are made in the\ndocsDevFilterCpeTable via learning.  If an attempt is\nmade to set this to a number greater than that\npermitted for the device, it is set to that maximum.")
docsDevCpeTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 7, 3))
if mibBuilder.loadTexts: docsDevCpeTable.setDescription("This table lists the IPv4 addresses seen (or permitted)\nas source addresses in packets originating from the\ncustomer interface on this device.  In addition, this\ntable can be provisioned with the specific addresses\npermitted for the CPEs via the normal row creation\nmechanisms.  Table entries MUST NOT persist across\nreboots for any device.\n\nN.B.  Management action can add entries in this table\nand in docsDevCpeIpTable past the value of\n\n\n\ndocsDevCpeIpMax.  docsDevCpeIpMax ONLY restricts the\nability of the CM to add learned addresses\nautomatically.\n\nThis table is deprecated and is replaced by\ndocsDevCpeInetTable.")
docsDevCpeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevCpeIp"))
if mibBuilder.loadTexts: docsDevCpeEntry.setDescription("An entry in the docsDevFilterCpeTable.  There is one\nentry for each IPv4 CPE seen or provisioned.  If\ndocsDevCpeIpMax is set to -1, this table is ignored;\notherwise, upon receipt of an IP packet from the\ncustomer interface of the CM, the source IP address is\nchecked against this table.  If the address is in the\ntable, packet processing continues.  If the address is\nnot in the table but docsDevCpeEnroll is set to any\nand the sum of the table sizes of docsDevCpeTable and\ndocsDevCpeInetTable is less than docsDevCpeIpMax, the\naddress is added to the table, and packet processing\ncontinues.  Otherwise, the packet is dropped.\n\nThe filtering actions specified by this table occur\nafter any LLC filtering (docsDevFilterLLCTable), but\nprior to any IP filtering (docsDevFilterIpTable,\ndocsDevNmAccessTable).")
docsDevCpeIp = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1, 1), IpAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevCpeIp.setDescription("The IPv4 address to which this entry applies.\n\nN.B.  Attempts to set all zeros or all ones address\nvalues MUST be rejected.")
docsDevCpeSource = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("manual", 2), ("learned", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevCpeSource.setDescription("This object describes how this entry was created.  If\nthe value is manual(2), this row was created by a\nnetwork management action (either configuration or\nSNMP set).  If set to learned(3), then it was found via\nlooking at the source IPv4 address of a received packet.\nThe value other(1) is used for any entries that do not\nmeet manual(2) or learned(3) criteria.")
docsDevCpeStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 3, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevCpeStatus.setDescription("Standard object to manipulate rows.  To create a row in\nthis table, one only needs to specify this object.\nManagement stations SHOULD use the create-and-go\nmechanism for creating rows in this table.")
docsDevCpeInetTable = MibTable((1, 3, 6, 1, 2, 1, 69, 1, 7, 4))
if mibBuilder.loadTexts: docsDevCpeInetTable.setDescription("This table lists the IP addresses seen (or permitted) as\nsource addresses in packets originating from the\ncustomer interface on this device.  In addition, this\ntable can be provisioned with the specific addresses\npermitted for the CPEs via the normal row creation\nmechanisms.\n\n\n\nN.B.  Management action can add entries in this table\nand in docsDevCpeIpTable past the value of\ndocsDevCpeIpMax.  docsDevCpeIpMax ONLY restricts the\nability of the CM to add learned addresses\nautomatically.\n\nTable entries MUST NOT persist across reboots for any\ndevice.\n\nThis table exactly mirrors docsDevCpeTable and applies\nto IPv4 and IPv6 addresses.")
docsDevCpeInetEntry = MibTableRow((1, 3, 6, 1, 2, 1, 69, 1, 7, 4, 1)).setIndexNames((0, "DOCS-CABLE-DEVICE-MIB", "docsDevCpeInetType"), (0, "DOCS-CABLE-DEVICE-MIB", "docsDevCpeInetAddr"))
if mibBuilder.loadTexts: docsDevCpeInetEntry.setDescription("An entry in the docsDevFilterCpeInetTable.  There is one\nentry for each IP CPE seen or provisioned.  If\ndocsDevCpeIpMax is set to -1, this table is ignored;\notherwise, upon receipt of an IP packet from the\ncustomer interface of the CM, the source IP address is\nchecked against this table.  If the address is in the\ntable, packet processing continues.  If the address is\nnot in the table but docsDevCpeEnroll is set to any and\nthe sum of the table sizes for docsDevCpeTable and\ndocsDevCpeInetTable is less than docsDevCpeIpMax, the\naddress is added to the table, and packet processing\ncontinues.  Otherwise, the packet is dropped.\n\nThe filtering actions specified by this table occur\nafter any LLC filtering (docsDevFilterLLCTable), but\nprior to any IP filtering (docsDevFilterIpTable,\ndocsDevNmAccessTable).\n\nWhen an agent (cable modem) restarts, then all\ndynamically created rows are lost.")
docsDevCpeInetType = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 4, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevCpeInetType.setDescription("The type of internet address of docsDevCpeInetAddr.")
docsDevCpeInetAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 4, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: docsDevCpeInetAddr.setDescription("The Internet address to which this entry applies.\n\nImplementors need to be aware that if the size of\ndocsDevCpeInetAddr exceeds 114 octets OIDs of\ninstances of columns in this row will have more\nthan 128 sub-identifiers and cannot be accessed\nusing SNMPv1, SNMPv2c, or SNMPv3.  Only unicast\naddress are allowed for this object.")
docsDevCpeInetSource = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 4, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,)).subtype(namedValues=NamedValues(("manual", 2), ("learned", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: docsDevCpeInetSource.setDescription("This object describes how this entry was created.  If\nthe value is manual(2), this row was created by a\nnetwork management action (either configuration or\nSNMP set).  If set to learned(3), then it was found\nvia looking at the source IP address of a received\npacket.")
docsDevCpeInetRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 69, 1, 7, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: docsDevCpeInetRowStatus.setDescription("Standard object to manipulate rows.  To create a row in\nthis table, one only needs to specify this object.\nManagement stations SHOULD use the create-and-go\nmechanism for creating rows in this table.")
docsDevNotification = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 2))
docsDevConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3))
docsDevGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3, 1))
docsDevCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3, 2))
docsDevGroupsV2 = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3, 3))
docsDevCompliancesV2 = MibIdentifier((1, 3, 6, 1, 2, 1, 69, 3, 4))

# Augmentions

# Groups

docsDevBaseGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 1)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevSerialNumber"), ("DOCS-CABLE-DEVICE-MIB", "docsDevRole"), ("DOCS-CABLE-DEVICE-MIB", "docsDevResetNow"), ("DOCS-CABLE-DEVICE-MIB", "docsDevDateTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSTPControl"), ) )
if mibBuilder.loadTexts: docsDevBaseGroup.setDescription("A collection of objects providing device status and\ncontrol.")
docsDevNmAccessGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 2)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessInterfaces"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIp"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessIpMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessCommunity"), ) )
if mibBuilder.loadTexts: docsDevNmAccessGroup.setDescription("A collection of objects for controlling access to SNMP\nobjects on cable devices.\n\nThis group has been deprecated because all the\nobjects have been deprecated in favor of SNMPv3 and\nCoexistence MIBs.")
docsDevSoftwareGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 3)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevSwCurrentVers"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwOperStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwFilename"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwServer"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwAdminStatus"), ) )
if mibBuilder.loadTexts: docsDevSoftwareGroup.setDescription("A collection of objects for controlling software\ndownloads.\n\nThis group has been deprecated and replaced by\ndocsDevSoftwareGroupV2.  Object docsDevSwServer\nhas been replaced by docsDevSwServerAddressType\nand docsDevSwServerAddress, and\ndocsDevSwServerTransportProtocol has been added to\nsupport TFTP and HTTP firmware downloads.")
docsDevServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 4)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevServerBootState"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerDhcp"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerTftp"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigFile"), ) )
if mibBuilder.loadTexts: docsDevServerGroup.setDescription("A collection of objects providing status about server\nprovisioning.\n\nThis group has been deprecated and replaced by\ndocsDevServerGroupV2.  The objects docsDevServerDhcp,\ndocsDevServerTime, and docsDevServerTftp have\nbeen replaced by docsDevServerDhcpAddressType,\ndocsDevServerDhcpAddress, docsDevServerTimeAddressType,\ndocsDevServerTimeAddress,\ndocsDevServerConfigTftpAddressType, and\ndocsDevServerConfigTftpAddress.")
docsDevEventGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 5)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevEvFirstTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInhibited"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleThreshold"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvLastTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvCounts"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvReporting"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleAdminStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvText"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInterval"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvSyslog"), ) )
if mibBuilder.loadTexts: docsDevEventGroup.setDescription("A collection of objects used to control and monitor\nevents.\n\nThis group has been deprecated and replaced by\ndocsDevEventGroupV2.  The object docsDevEvSyslog has\n\n\n\nbeen replaced by docsDevEvSyslogAddressType and\ndocsDevEvSyslogAddress, and docsDevEvThrottleInhibited\nhas been replaced by\ndocsDevEvThrottleThresholdExceeded.")
docsDevFilterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 6)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpTosMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpProtocol"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpBroadcast"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCMatches"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDestPortLow"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpContinue"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDaddr"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDmask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDefault"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSaddr"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSourcePortHigh"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpPolicyId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocolType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocol"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyPtr"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSourcePortLow"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCUnmatchedAction"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterPolicyId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosOrMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIfIndex"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpTos"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterTosAndMask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpSmask"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpMatches"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDirection"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpIfIndex"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterIpDestPortHigh"), ) )
if mibBuilder.loadTexts: docsDevFilterGroup.setDescription("A collection of objects to specify filters at the link\nlayer and IPv4 layer.\n\nThis group has been deprecated and replaced by various\ngroups from the DiffServ MIB.")
docsDevCpeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 1, 7)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevCpeIpMax"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeEnroll"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeSource"), ) )
if mibBuilder.loadTexts: docsDevCpeGroup.setDescription("A collection of objects used to control the number\nand specific values of IPv4 addresses allowed for\nassociated Customer Premises Equipment (CPE).\n\nThis group has been deprecated and replaced by\ndocsDevInetCpeGroup.  The object docsDevCpeSource has\nbeen replaced by docsDevCpeInetSource, and\ndocsDevCpeStatus has been replaced by\ndocsDevCpeInetRowStatus.")
docsDevBaseIgmpGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 1)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevIgmpModeControl"), ) )
if mibBuilder.loadTexts: docsDevBaseIgmpGroup.setDescription("An object providing cable device IGMP status and\ncontrol.")
docsDevBaseMaxCpeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 2)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevMaxCpe"), ) )
if mibBuilder.loadTexts: docsDevBaseMaxCpeGroup.setDescription("An object providing management of the maximum number of\nCPEs permitted access through a cable modem.")
docsDevNmAccessExtGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 3)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessTrapVersion"), ) )
if mibBuilder.loadTexts: docsDevNmAccessExtGroup.setDescription("An object, in addition to the objects in\ndocsDevNmAccessGroup, for controlling access to\nSNMP objects on cable devices.\n\nThis group is included in this MIB due to existing\nimplementations of docsDevNmAccessTrapVersion in\nDOCSIS cable modems.\n\nThis group has been deprecated because the object has\nbeen deprecated in favor of SNMPv3 and Coexistence\nMIBs.")
docsDevSoftwareGroupV2 = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 4)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevSwServerAddressType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwServerAddress"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwFilename"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwCurrentVers"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwServerTransportProtocol"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwAdminStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSwOperStatus"), ) )
if mibBuilder.loadTexts: docsDevSoftwareGroupV2.setDescription("A collection of objects for controlling software\ndownloads.  This group replaces docsDevSoftwareGroup.")
docsDevServerGroupV2 = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 5)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevServerTimeAddress"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigFile"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerDhcpAddress"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerDhcpAddressType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerBootState"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigTftpAddressType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerTimeAddressType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerConfigTftpAddress"), ) )
if mibBuilder.loadTexts: docsDevServerGroupV2.setDescription("A collection of objects providing status about server\nprovisioning.  This group replaces docsDevServerGroup.")
docsDevEventGroupV2 = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 6)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevEvFirstTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleThreshold"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleThresholdExceeded"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvLastTime"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvLevel"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvCounts"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvControl"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvId"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvReporting"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleAdminStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvText"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvThrottleInterval"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvSyslogAddress"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEvSyslogAddressType"), ) )
if mibBuilder.loadTexts: docsDevEventGroupV2.setDescription("A collection of objects used to control and monitor\nevents.  This group replaces docsDevEventGroup.\nThe event reporting mechanism, and more specifically\ndocsDevEvReporting, can be used to take advantage of\nthe event reporting features of RFC3413 and RFC3014.")
docsDevFilterLLCGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 7)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCUnmatchedAction"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCMatches"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCIfIndex"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocolType"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCProtocol"), ) )
if mibBuilder.loadTexts: docsDevFilterLLCGroup.setDescription("A collection of objects to specify link layer filters.")
docsDevInetCpeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 69, 3, 3, 8)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevCpeIpMax"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeInetRowStatus"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeEnroll"), ("DOCS-CABLE-DEVICE-MIB", "docsDevCpeInetSource"), ) )
if mibBuilder.loadTexts: docsDevInetCpeGroup.setDescription("A collection of objects used to control the number\nand specific values of Internet (e.g., IPv4 and IPv6)\naddresses allowed for associated Customer Premises\nEquipment (CPE).")

# Compliances

docsDevBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 69, 3, 2, 1)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevCpeGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevBaseGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEventGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevNmAccessGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroup"), ) )
if mibBuilder.loadTexts: docsDevBasicCompliance.setDescription("The RFC 2669 compliance statement for MCNS/DOCSIS\nCable Modems and Cable Modem Termination Systems.")
docsDevCmCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 69, 3, 4, 1)).setObjects(*(("DIFFSERV-MIB", "diffServMIBMultiFieldClfrGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevBaseMaxCpeGroup"), ("DIFFSERV-MIB", "diffServMIBClfrElementGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevBaseGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEventGroupV2"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerGroupV2"), ("DOCS-CABLE-DEVICE-MIB", "docsDevInetCpeGroup"), ("DIFFSERV-MIB", "diffServMIBAlgDropGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevBaseIgmpGroup"), ("DIFFSERV-MIB", "diffServMIBClfrGroup"), ("DIFFSERV-MIB", "diffServMIBActionGroup"), ("DIFFSERV-MIB", "diffServMIBCounterGroup"), ("DIFFSERV-MIB", "diffServMIBDscpMarkActGroup"), ("DIFFSERV-MIB", "diffServMIBDataPathGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroupV2"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCGroup"), ) )
if mibBuilder.loadTexts: docsDevCmCompliance.setDescription("The compliance statement for DOCSIS Cable Modems.\n\nThis compliance statement applies to implementations\nof DOCSIS versions that are not IPv6 capable.")
docsDevCmtsCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 69, 3, 4, 2)).setObjects(*(("DOCS-CABLE-DEVICE-MIB", "docsDevBaseMaxCpeGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevBaseGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevEventGroupV2"), ("DOCS-CABLE-DEVICE-MIB", "docsDevServerGroupV2"), ("DOCS-CABLE-DEVICE-MIB", "docsDevInetCpeGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevSoftwareGroupV2"), ("DOCS-CABLE-DEVICE-MIB", "docsDevFilterLLCGroup"), ("DOCS-CABLE-DEVICE-MIB", "docsDevBaseIgmpGroup"), ) )
if mibBuilder.loadTexts: docsDevCmtsCompliance.setDescription("The compliance statement for DOCSIS Cable Modem\nTermination Systems.\n\nThis compliance statement applies to implementations\nof DOCSIS versions that are not IPv6 capable.")

# Exports

# Module identity
mibBuilder.exportSymbols("DOCS-CABLE-DEVICE-MIB", PYSNMP_MODULE_ID=docsDev)

# Objects
mibBuilder.exportSymbols("DOCS-CABLE-DEVICE-MIB", docsDev=docsDev, docsDevNotifications=docsDevNotifications, docsDevMIBObjects=docsDevMIBObjects, docsDevBase=docsDevBase, docsDevRole=docsDevRole, docsDevDateTime=docsDevDateTime, docsDevResetNow=docsDevResetNow, docsDevSerialNumber=docsDevSerialNumber, docsDevSTPControl=docsDevSTPControl, docsDevIgmpModeControl=docsDevIgmpModeControl, docsDevMaxCpe=docsDevMaxCpe, docsDevNmAccessTable=docsDevNmAccessTable, docsDevNmAccessEntry=docsDevNmAccessEntry, docsDevNmAccessIndex=docsDevNmAccessIndex, docsDevNmAccessIp=docsDevNmAccessIp, docsDevNmAccessIpMask=docsDevNmAccessIpMask, docsDevNmAccessCommunity=docsDevNmAccessCommunity, docsDevNmAccessControl=docsDevNmAccessControl, docsDevNmAccessInterfaces=docsDevNmAccessInterfaces, docsDevNmAccessStatus=docsDevNmAccessStatus, docsDevNmAccessTrapVersion=docsDevNmAccessTrapVersion, docsDevSoftware=docsDevSoftware, docsDevSwServer=docsDevSwServer, docsDevSwFilename=docsDevSwFilename, docsDevSwAdminStatus=docsDevSwAdminStatus, docsDevSwOperStatus=docsDevSwOperStatus, docsDevSwCurrentVers=docsDevSwCurrentVers, docsDevSwServerAddressType=docsDevSwServerAddressType, docsDevSwServerAddress=docsDevSwServerAddress, docsDevSwServerTransportProtocol=docsDevSwServerTransportProtocol, docsDevServer=docsDevServer, docsDevServerBootState=docsDevServerBootState, docsDevServerDhcp=docsDevServerDhcp, docsDevServerTime=docsDevServerTime, docsDevServerTftp=docsDevServerTftp, docsDevServerConfigFile=docsDevServerConfigFile, docsDevServerDhcpAddressType=docsDevServerDhcpAddressType, docsDevServerDhcpAddress=docsDevServerDhcpAddress, docsDevServerTimeAddressType=docsDevServerTimeAddressType, docsDevServerTimeAddress=docsDevServerTimeAddress, docsDevServerConfigTftpAddressType=docsDevServerConfigTftpAddressType, docsDevServerConfigTftpAddress=docsDevServerConfigTftpAddress, docsDevEvent=docsDevEvent, docsDevEvControl=docsDevEvControl, docsDevEvSyslog=docsDevEvSyslog, docsDevEvThrottleAdminStatus=docsDevEvThrottleAdminStatus, docsDevEvThrottleInhibited=docsDevEvThrottleInhibited, docsDevEvThrottleThreshold=docsDevEvThrottleThreshold, docsDevEvThrottleInterval=docsDevEvThrottleInterval, docsDevEvControlTable=docsDevEvControlTable, docsDevEvControlEntry=docsDevEvControlEntry, docsDevEvPriority=docsDevEvPriority, docsDevEvReporting=docsDevEvReporting, docsDevEventTable=docsDevEventTable, docsDevEventEntry=docsDevEventEntry, docsDevEvIndex=docsDevEvIndex, docsDevEvFirstTime=docsDevEvFirstTime, docsDevEvLastTime=docsDevEvLastTime, docsDevEvCounts=docsDevEvCounts, docsDevEvLevel=docsDevEvLevel, docsDevEvId=docsDevEvId, docsDevEvText=docsDevEvText, docsDevEvSyslogAddressType=docsDevEvSyslogAddressType, docsDevEvSyslogAddress=docsDevEvSyslogAddress, docsDevEvThrottleThresholdExceeded=docsDevEvThrottleThresholdExceeded, docsDevFilter=docsDevFilter, docsDevFilterLLCUnmatchedAction=docsDevFilterLLCUnmatchedAction, docsDevFilterLLCTable=docsDevFilterLLCTable, docsDevFilterLLCEntry=docsDevFilterLLCEntry, docsDevFilterLLCIndex=docsDevFilterLLCIndex, docsDevFilterLLCStatus=docsDevFilterLLCStatus, docsDevFilterLLCIfIndex=docsDevFilterLLCIfIndex, docsDevFilterLLCProtocolType=docsDevFilterLLCProtocolType, docsDevFilterLLCProtocol=docsDevFilterLLCProtocol, docsDevFilterLLCMatches=docsDevFilterLLCMatches, docsDevFilterIpDefault=docsDevFilterIpDefault, docsDevFilterIpTable=docsDevFilterIpTable, docsDevFilterIpEntry=docsDevFilterIpEntry, docsDevFilterIpIndex=docsDevFilterIpIndex, docsDevFilterIpStatus=docsDevFilterIpStatus, docsDevFilterIpControl=docsDevFilterIpControl, docsDevFilterIpIfIndex=docsDevFilterIpIfIndex, docsDevFilterIpDirection=docsDevFilterIpDirection, docsDevFilterIpBroadcast=docsDevFilterIpBroadcast, docsDevFilterIpSaddr=docsDevFilterIpSaddr, docsDevFilterIpSmask=docsDevFilterIpSmask, docsDevFilterIpDaddr=docsDevFilterIpDaddr, docsDevFilterIpDmask=docsDevFilterIpDmask, docsDevFilterIpProtocol=docsDevFilterIpProtocol, docsDevFilterIpSourcePortLow=docsDevFilterIpSourcePortLow, docsDevFilterIpSourcePortHigh=docsDevFilterIpSourcePortHigh, docsDevFilterIpDestPortLow=docsDevFilterIpDestPortLow, docsDevFilterIpDestPortHigh=docsDevFilterIpDestPortHigh, docsDevFilterIpMatches=docsDevFilterIpMatches, docsDevFilterIpTos=docsDevFilterIpTos, docsDevFilterIpTosMask=docsDevFilterIpTosMask, docsDevFilterIpContinue=docsDevFilterIpContinue, docsDevFilterIpPolicyId=docsDevFilterIpPolicyId, docsDevFilterPolicyTable=docsDevFilterPolicyTable, docsDevFilterPolicyEntry=docsDevFilterPolicyEntry, docsDevFilterPolicyIndex=docsDevFilterPolicyIndex, docsDevFilterPolicyId=docsDevFilterPolicyId, docsDevFilterPolicyStatus=docsDevFilterPolicyStatus, docsDevFilterPolicyPtr=docsDevFilterPolicyPtr, docsDevFilterTosTable=docsDevFilterTosTable, docsDevFilterTosEntry=docsDevFilterTosEntry, docsDevFilterTosIndex=docsDevFilterTosIndex, docsDevFilterTosStatus=docsDevFilterTosStatus, docsDevFilterTosAndMask=docsDevFilterTosAndMask, docsDevFilterTosOrMask=docsDevFilterTosOrMask, docsDevCpe=docsDevCpe, docsDevCpeEnroll=docsDevCpeEnroll, docsDevCpeIpMax=docsDevCpeIpMax, docsDevCpeTable=docsDevCpeTable, docsDevCpeEntry=docsDevCpeEntry, docsDevCpeIp=docsDevCpeIp, docsDevCpeSource=docsDevCpeSource, docsDevCpeStatus=docsDevCpeStatus, docsDevCpeInetTable=docsDevCpeInetTable, docsDevCpeInetEntry=docsDevCpeInetEntry, docsDevCpeInetType=docsDevCpeInetType, docsDevCpeInetAddr=docsDevCpeInetAddr, docsDevCpeInetSource=docsDevCpeInetSource, docsDevCpeInetRowStatus=docsDevCpeInetRowStatus, docsDevNotification=docsDevNotification, docsDevConformance=docsDevConformance)
mibBuilder.exportSymbols("DOCS-CABLE-DEVICE-MIB", docsDevGroups=docsDevGroups, docsDevCompliances=docsDevCompliances, docsDevGroupsV2=docsDevGroupsV2, docsDevCompliancesV2=docsDevCompliancesV2)

# Groups
mibBuilder.exportSymbols("DOCS-CABLE-DEVICE-MIB", docsDevBaseGroup=docsDevBaseGroup, docsDevNmAccessGroup=docsDevNmAccessGroup, docsDevSoftwareGroup=docsDevSoftwareGroup, docsDevServerGroup=docsDevServerGroup, docsDevEventGroup=docsDevEventGroup, docsDevFilterGroup=docsDevFilterGroup, docsDevCpeGroup=docsDevCpeGroup, docsDevBaseIgmpGroup=docsDevBaseIgmpGroup, docsDevBaseMaxCpeGroup=docsDevBaseMaxCpeGroup, docsDevNmAccessExtGroup=docsDevNmAccessExtGroup, docsDevSoftwareGroupV2=docsDevSoftwareGroupV2, docsDevServerGroupV2=docsDevServerGroupV2, docsDevEventGroupV2=docsDevEventGroupV2, docsDevFilterLLCGroup=docsDevFilterLLCGroup, docsDevInetCpeGroup=docsDevInetCpeGroup)

# Compliances
mibBuilder.exportSymbols("DOCS-CABLE-DEVICE-MIB", docsDevBasicCompliance=docsDevBasicCompliance, docsDevCmCompliance=docsDevCmCompliance, docsDevCmtsCompliance=docsDevCmtsCompliance)
