# PySNMP SMI module. Autogenerated from smidump -f python MPLS-L3VPN-STD-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:58:04 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( IANAipRouteProtocol, ) = mibBuilder.importSymbols("IANA-RTPROTO-MIB", "IANAipRouteProtocol")
( InterfaceIndex, InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
( InetAddress, InetAddressPrefixLength, InetAddressType, InetAutonomousSystemNumber, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressPrefixLength", "InetAddressType", "InetAutonomousSystemNumber")
( MplsIndexType, ) = mibBuilder.importSymbols("MPLS-LSR-STD-MIB", "MplsIndexType")
( mplsStdMIB, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "mplsStdMIB")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( RowStatus, StorageType, TextualConvention, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TextualConvention", "TimeStamp", "TruthValue")
( VPNIdOrZero, ) = mibBuilder.importSymbols("VPN-TC-STD-MIB", "VPNIdOrZero")

# Types

class MplsL3VpnName(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,31)
    
class MplsL3VpnRouteDistinguisher(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,256)
    
class MplsL3VpnRtType(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(3,2,1,)
    namedValues = NamedValues(("import", 1), ("export", 2), ("both", 3), )
    

# Objects

mplsL3VpnMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 11)).setRevisions(("2006-01-23 00:00",))
if mibBuilder.loadTexts: mplsL3VpnMIB.setOrganization("IETF Layer-3 Virtual Private\nNetworks Working Group.")
if mibBuilder.loadTexts: mplsL3VpnMIB.setContactInfo("        Thomas D. Nadeau\ntnadeau@cisco.com\n\nHarmen van der Linde\nhavander@cisco.com\n\nComments and discussion to l3vpn@ietf.org")
if mibBuilder.loadTexts: mplsL3VpnMIB.setDescription("This MIB contains managed object definitions for the\nLayer-3 Multiprotocol Label Switching Virtual\nPrivate Networks.\n\nCopyright (C) The Internet Society (2006).  This\nversion of this MIB module is part of RFC4382; see\nthe RFC itself for full legal notices.")
mplsL3VpnNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 0))
mplsL3VpnObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 1))
mplsL3VpnScalars = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1))
mplsL3VpnConfiguredVrfs = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnConfiguredVrfs.setDescription("The number of VRFs that are configured on this node.")
mplsL3VpnActiveVrfs = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnActiveVrfs.setDescription("The number of VRFs that are active on this node.\nThat is, those VRFs whose corresponding mplsL3VpnVrfOperStatus\nobject value is equal to operational (1).")
mplsL3VpnConnectedInterfaces = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnConnectedInterfaces.setDescription("Total number of interfaces connected to a VRF.")
mplsL3VpnNotificationEnable = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsL3VpnNotificationEnable.setDescription("If this object is true, then it enables the\ngeneration of all notifications defined in\nthis MIB.  This object's value should be\npreserved across agent reboots.")
mplsL3VpnVrfConfMaxPossRts = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfConfMaxPossRts.setDescription("Denotes maximum number of routes that the device\nwill allow all VRFs jointly to hold.  If this value is\nset to 0, this indicates that the device is\nunable to determine the absolute maximum.  In this\ncase, the configured maximum MAY not actually\nbe allowed by the device.")
mplsL3VpnVrfConfRteMxThrshTime = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 6), Unsigned32().clone(0)).setMaxAccess("readonly").setUnits("seconds")
if mibBuilder.loadTexts: mplsL3VpnVrfConfRteMxThrshTime.setDescription("Denotes the interval in seconds, at which the route max threshold\nnotification may be reissued after the maximum value has been\nexceeded (or has been reached if mplsL3VpnVrfConfMaxRoutes and\nmplsL3VpnVrfConfHighRteThresh are equal) and the initial\nnotification has been issued.  This value is intended to prevent\ncontinuous generation of notifications by an agent in the event\nthat routes are continually added to a VRF after it has reached\nits maximum value.  If this value is set to 0, the agent should\nonly issue a single notification at the time that the maximum\nthreshold has been reached, and should not issue any more\nnotifications until the value of routes has fallen below the\nconfigured threshold value.  This is the recommended default\nbehavior.")
mplsL3VpnIllLblRcvThrsh = MibScalar((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 1, 7), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mplsL3VpnIllLblRcvThrsh.setDescription("The number of illegally received labels above which\nthe mplsNumVrfSecIllglLblThrshExcd notification\nis issued.  The persistence of this value mimics\nthat of the device's configuration.")
mplsL3VpnConf = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2))
mplsL3VpnIfConfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1))
if mibBuilder.loadTexts: mplsL3VpnIfConfTable.setDescription("This table specifies per-interface MPLS capability\nand associated information.")
mplsL3VpnIfConfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1, 1)).setIndexNames((0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfName"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnIfConfIndex"))
if mibBuilder.loadTexts: mplsL3VpnIfConfEntry.setDescription("An entry in this table is created by an LSR for\nevery interface capable of supporting MPLS L3VPN.\nEach entry in this table is meant to correspond to\nan entry in the Interfaces Table.")
mplsL3VpnIfConfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1, 1, 1), InterfaceIndex()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnIfConfIndex.setDescription("This is a unique index for an entry in the\nmplsL3VpnIfConfTable.  A non-zero index for an\nentry indicates the ifIndex for the corresponding\ninterface entry in the MPLS-VPN-layer in the ifTable.\nNote that this table does not necessarily correspond\none-to-one with all entries in the Interface MIB\nhaving an ifType of MPLS-layer; rather, only those\nthat are enabled for MPLS L3VPN functionality.")
mplsL3VpnIfVpnClassification = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("carrierOfCarrier", 1), ("enterprise", 2), ("interProvider", 3), )).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnIfVpnClassification.setDescription("Denotes whether this link participates in a\ncarrier's carrier, enterprise, or inter-provider\nscenario.")
mplsL3VpnIfVpnRouteDistProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1, 1, 3), Bits().subtype(namedValues=NamedValues(("none", 0), ("bgp", 1), ("ospf", 2), ("rip", 3), ("isis", 4), ("static", 5), ("other", 6), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnIfVpnRouteDistProtocol.setDescription("Denotes the route distribution protocol across the\nPE-CE link.  Note that more than one routing protocol\nmay be enabled at the same time; thus, this object is\nspecified as a bitmask.  For example, static(5) and\nospf(2) are a typical configuration.")
mplsL3VpnIfConfStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1, 1, 4), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnIfConfStorageType.setDescription("The storage type for this VPN If entry.\nConceptual rows having the value 'permanent'\nneed not allow write access to any columnar\nobjects in the row.")
mplsL3VpnIfConfRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnIfConfRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.  Rows in this\ntable signify that the specified interface is\nassociated with this VRF.  If the row creation\noperation succeeds, the interface will have been\nassociated with the specified VRF, otherwise the\nagent MUST not allow the association.  If the agent\nonly allows read-only operations on this table, it\nMUST create entries in this table as they are created\non the device.  When a row in this table is in\nactive(1) state, no objects in that row can be\nmodified except mplsL3VpnIfConfStorageType and\nmplsL3VpnIfConfRowStatus.")
mplsL3VpnVrfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2))
if mibBuilder.loadTexts: mplsL3VpnVrfTable.setDescription("This table specifies per-interface MPLS L3VPN\nVRF Table capability and associated information.\nEntries in this table define VRF routing instances\nassociated with MPLS/VPN interfaces.  Note that\nmultiple interfaces can belong to the same VRF\ninstance.  The collection of all VRF instances\ncomprises an actual VPN.")
mplsL3VpnVrfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1)).setIndexNames((0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfName"))
if mibBuilder.loadTexts: mplsL3VpnVrfEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS L3VPN.  The\nindexing provides an ordering of VRFs per-VPN\ninterface.")
mplsL3VpnVrfName = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 1), MplsL3VpnName()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfName.setDescription("The human-readable name of this VPN.  This MAY\nbe equivalent to the [RFC2685] VPN-ID, but may\nalso vary.  If it is set to the VPN ID, it MUST\nbe equivalent to the value of mplsL3VpnVrfVpnId.\nIt is strongly recommended that all sites supporting\nVRFs that are part of the same VPN use the same\nnaming convention for VRFs as well as the same VPN\nID.")
mplsL3VpnVrfVpnId = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 2), VPNIdOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfVpnId.setDescription("The VPN ID as specified in [RFC2685].  If a VPN ID\nhas not been specified for this VRF, then this\nvariable SHOULD be set to a zero-length OCTET\nSTRING.")
mplsL3VpnVrfDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 3), SnmpAdminString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfDescription.setDescription("The human-readable description of this VRF.")
mplsL3VpnVrfRD = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 4), MplsL3VpnRouteDistinguisher().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRD.setDescription("The route distinguisher for this VRF.")
mplsL3VpnVrfCreationTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfCreationTime.setDescription("The time at which this VRF entry was created.")
mplsL3VpnVrfOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfOperStatus.setDescription("Denotes whether or not a VRF is operational.  A VRF is\nup(1) when there is at least one interface associated\nwith the VRF whose ifOperStatus is up(1).  A VRF is\ndown(2) when:\na. There does not exist at least one interface whose\n   ifOperStatus is up(1).\nb. There are no interfaces associated with the VRF.")
mplsL3VpnVrfActiveInterfaces = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfActiveInterfaces.setDescription("Total number of interfaces connected to this VRF with\nifOperStatus = up(1).\n\nThis value should increase when an interface is associated\nwith the corresponding VRF and its corresponding ifOperStatus\nis equal to up(1).  If an interface is associated whose\nifOperStatus is not up(1), then the value is not incremented\nuntil such time as it transitions to this state.\n\nThis value should be decremented when an interface is\ndisassociated with a VRF or the corresponding ifOperStatus\ntransitions out of the up(1) state to any other state.")
mplsL3VpnVrfAssociatedInterfaces = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfAssociatedInterfaces.setDescription("Total number of interfaces connected to this VRF\n(independent of ifOperStatus type).")
mplsL3VpnVrfConfMidRteThresh = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 9), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfConfMidRteThresh.setDescription("Denotes mid-level water marker for the number\nof routes that this VRF may hold.")
mplsL3VpnVrfConfHighRteThresh = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 10), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfConfHighRteThresh.setDescription("Denotes high-level water marker for the number of\nroutes that this VRF may hold.")
mplsL3VpnVrfConfMaxRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 11), Unsigned32().clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfConfMaxRoutes.setDescription("Denotes maximum number of routes that this VRF is\nconfigured to hold.  This value MUST be less than or\nequal to mplsL3VpnVrfConfMaxPossRts unless it is set\nto 0.")
mplsL3VpnVrfConfLastChanged = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 12), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfConfLastChanged.setDescription("The value of sysUpTime at the time of the last\nchange of this table entry, which includes changes of\nVRF parameters defined in this table or addition or\ndeletion of interfaces associated with this VRF.")
mplsL3VpnVrfConfRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfConfRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.\n\n\n\n\nWhen a row in this table is in active(1) state, no\nobjects in that row can be modified except\nmplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\nand mplsL3VpnVrfConfStorageType.")
mplsL3VpnVrfConfAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(2,3,1,)).subtype(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfConfAdminStatus.setDescription("Indicates the desired operational status of this\nVRF.")
mplsL3VpnVrfConfStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 2, 1, 15), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfConfStorageType.setDescription("The storage type for this VPN VRF entry.\nConceptual rows having the value 'permanent'\nneed not allow write access to any columnar\nobjects in the row.")
mplsL3VpnVrfRTTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3))
if mibBuilder.loadTexts: mplsL3VpnVrfRTTable.setDescription("This table specifies per-VRF route target association.\nEach entry identifies a connectivity policy supported\nas part of a VPN.")
mplsL3VpnVrfRTEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1)).setIndexNames((0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfName"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTIndex"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTType"))
if mibBuilder.loadTexts: mplsL3VpnVrfRTEntry.setDescription("An entry in this table is created by an LSR for\neach route target configured for a VRF supporting\na MPLS L3VPN instance.  The indexing provides an\nordering per-VRF instance.  See [RFC4364] for a\ncomplete definition of a route target.")
mplsL3VpnVrfRTIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRTIndex.setDescription("Auxiliary index for route targets configured for a\nparticular VRF.")
mplsL3VpnVrfRTType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1, 3), MplsL3VpnRtType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRTType.setDescription("The route target distribution type.")
mplsL3VpnVrfRT = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1, 4), MplsL3VpnRouteDistinguisher().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRT.setDescription("The route target distribution policy.")
mplsL3VpnVrfRTDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1, 5), SnmpAdminString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRTDescr.setDescription("Description of the route target.")
mplsL3VpnVrfRTRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRTRowStatus.setDescription("This variable is used to create, modify, and/or\ndelete a row in this table.  When a row in this\ntable is in active(1) state, no objects in that row\ncan be modified except mplsL3VpnVrfRTRowStatus.")
mplsL3VpnVrfRTStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 3, 1, 7), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRTStorageType.setDescription("The storage type for this VPN route target (RT) entry.\nConceptual rows having the value 'permanent'\nneed not allow write access to any columnar\nobjects in the row.")
mplsL3VpnVrfSecTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 6))
if mibBuilder.loadTexts: mplsL3VpnVrfSecTable.setDescription("This table specifies per MPLS L3VPN VRF Table\nsecurity-related counters.")
mplsL3VpnVrfSecEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 6, 1))
if mibBuilder.loadTexts: mplsL3VpnVrfSecEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS L3VPN.  Each\nentry in this table is used to indicate security-related\ninformation for each VRF entry.")
mplsL3VpnVrfSecIllegalLblVltns = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 6, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfSecIllegalLblVltns.setDescription("Indicates the number of illegally received\nlabels on this VPN/VRF.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\nmplsL3VpnVrfSecDiscontinuityTime.")
mplsL3VpnVrfSecDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 2, 6, 1, 2), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfSecDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at\nwhich any one or more of this entry's counters suffered\na discontinuity.  If no such discontinuities have\noccurred since the last re-initialization of the local\nmanagement subsystem, then this object contains a zero\nvalue.")
mplsL3VpnPerf = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3))
mplsL3VpnVrfPerfTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1))
if mibBuilder.loadTexts: mplsL3VpnVrfPerfTable.setDescription("This table specifies per MPLS L3VPN VRF Table performance\n\n\n\ninformation.")
mplsL3VpnVrfPerfEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1, 1))
if mibBuilder.loadTexts: mplsL3VpnVrfPerfEntry.setDescription("An entry in this table is created by an LSR for\nevery VRF capable of supporting MPLS L3VPN.")
mplsL3VpnVrfPerfRoutesAdded = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfPerfRoutesAdded.setDescription("Indicates the number of routes added to this VPN/VRF\nsince the last discontinuity.  Discontinuities in\nthe value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\nmplsL3VpnVrfPerfDiscTime.")
mplsL3VpnVrfPerfRoutesDeleted = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfPerfRoutesDeleted.setDescription("Indicates the number of routes removed from this VPN/VRF.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\nmplsL3VpnVrfPerfDiscTime.")
mplsL3VpnVrfPerfCurrNumRoutes = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfPerfCurrNumRoutes.setDescription("Indicates the number of routes currently used by this\nVRF.")
mplsL3VpnVrfPerfRoutesDropped = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfPerfRoutesDropped.setDescription("This counter should be incremented when the number of routes\ncontained by the specified VRF exceeds or attempts to exceed\nthe maximum allowed value as indicated by\nmplsL3VpnVrfMaxRouteThreshold.\n\nDiscontinuities in the value of this counter can occur\nat re-initialization of the management system, and at\nother times as indicated by the value of\nmplsL3VpnVrfPerfDiscTime.")
mplsL3VpnVrfPerfDiscTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 3, 1, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfPerfDiscTime.setDescription("The value of sysUpTime on the most recent occasion at\nwhich any one or more of this entry's counters suffered\na discontinuity.  If no such discontinuities have\noccurred since the last re-initialization of the local\nmanagement subsystem, then this object contains a zero\nvalue.")
mplsL3VpnRoute = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4))
mplsL3VpnVrfRteTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1))
if mibBuilder.loadTexts: mplsL3VpnVrfRteTable.setDescription("This table specifies per-interface MPLS L3VPN VRF Table\nrouting information.  Entries in this table define VRF routing\nentries associated with the specified MPLS/VPN interfaces.  Note\n\n\n\nthat this table contains both BGP and Interior Gateway Protocol\nIGP routes, as both may appear in the same VRF.")
mplsL3VpnVrfRteEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1)).setIndexNames((0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfName"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrDestType"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrDest"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrPfxLen"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrPolicy"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrNHopType"), (0, "MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrNextHop"))
if mibBuilder.loadTexts: mplsL3VpnVrfRteEntry.setDescription("An entry in this table is created by an LSR for every route\npresent configured (either dynamically or statically) within\nthe context of a specific VRF capable of supporting MPLS/BGP\nVPN.  The indexing provides an ordering of VRFs per-VPN\ninterface.\n\nImplementers need to be aware that there are quite a few\nindex objects that together can exceed the size allowed\nfor an Object Identifier (OID).  So implementers must make\nsure that OIDs of column instances in this table will have\nno more than 128 sub-identifiers, otherwise they cannot be\naccessed using SNMPv1, SNMPv2c, or SNMPv3.")
mplsL3VpnVrfRteInetCidrDestType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrDestType.setDescription("The type of the mplsL3VpnVrfRteInetCidrDest address, as\ndefined in the InetAddress MIB.\n\nOnly those address types that may appear in an actual\nrouting table are allowed as values of this object.")
mplsL3VpnVrfRteInetCidrDest = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrDest.setDescription("The destination IP address of this route.\n\nThe type of this address is determined by the value of\nthe mplsL3VpnVrfRteInetCidrDestType object.\n\nThe values for the index objects\nmplsL3VpnVrfRteInetCidrDest and\nmplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\nthe value of mplsL3VpnVrfRteInetCidrDest is x, then\nthe bitwise logical-AND of x with the value of the mask\nformed from the corresponding index object\nmplsL3VpnVrfRteInetCidrPfxLen MUST be\nequal to x.  If not, then the index pair is not\nconsistent and an inconsistentName error must be\nreturned on SET or CREATE requests.")
mplsL3VpnVrfRteInetCidrPfxLen = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 3), InetAddressPrefixLength().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrPfxLen.setDescription("Indicates the number of leading one bits that form the\n\n\n\nmask to be logical-ANDed with the destination address\nbefore being compared to the value in the\nmplsL3VpnVrfRteInetCidrDest field.\n\nThe values for the index objects\nmplsL3VpnVrfRteInetCidrDest and\nmplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\nthe value of mplsL3VpnVrfRteInetCidrDest is x, then the\nbitwise logical-AND of x with the value of the mask\nformed from the corresponding index object\nmplsL3VpnVrfRteInetCidrPfxLen MUST be\nequal to x.  If not, then the index pair is not\nconsistent and an inconsistentName error must be\nreturned on SET or CREATE requests.")
mplsL3VpnVrfRteInetCidrPolicy = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 4), ObjectIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrPolicy.setDescription("This object is an opaque object without any defined\nsemantics.  Its purpose is to serve as an additional\nindex that may delineate between multiple entries to\nthe same destination.  The value { 0 0 } shall be used\nas the default value for this object.")
mplsL3VpnVrfRteInetCidrNHopType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 5), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrNHopType.setDescription("The type of the mplsL3VpnVrfRteInetCidrNextHop address,\nas defined in the InetAddress MIB.\n\nValue should be set to unknown(0) for non-remote\nroutes.\n\nOnly those address types that may appear in an actual\nrouting table are allowed as values of this object.")
mplsL3VpnVrfRteInetCidrNextHop = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 6), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrNextHop.setDescription("On remote routes, the address of the next system en\nroute.  For non-remote routes, a zero-length string.\nThe type of this address is determined by the value of\nthe mplsL3VpnVrfRteInetCidrNHopType object.")
mplsL3VpnVrfRteInetCidrIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 7), InterfaceIndexOrZero().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrIfIndex.setDescription("The ifIndex value that identifies the local interface\nthrough which the next hop of this route should be\nreached.  A value of 0 is valid and represents the\nscenario where no interface is specified.")
mplsL3VpnVrfRteInetCidrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(4,5,1,2,3,)).subtype(namedValues=NamedValues(("other", 1), ("reject", 2), ("local", 3), ("remote", 4), ("blackhole", 5), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrType.setDescription("The type of route.  Note that local(3) refers to a\nroute for which the next hop is the final destination;\nremote(4) refers to a route for which the next hop is\nnot the final destination.\n\nRoutes that do not result in traffic forwarding or\nrejection should not be displayed even if the\nimplementation keeps them stored internally.\n\nreject(2) refers to a route that, if matched, discards\nthe message as unreachable and returns a notification\n(e.g., ICMP error) to the message sender.  This is used\nin some protocols as a means of correctly aggregating\nroutes.\n\nblackhole(5) refers to a route that, if matched,\n\n\n\ndiscards the message silently.")
mplsL3VpnVrfRteInetCidrProto = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 9), IANAipRouteProtocol()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrProto.setDescription("The routing mechanism via which this route was learned.\nInclusion of values for gateway routing protocols is\nnot intended to imply that hosts should support those\nprotocols.")
mplsL3VpnVrfRteInetCidrAge = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrAge.setDescription("The number of seconds since this route was last updated\nor otherwise determined to be correct.  Note that no\nsemantics of 'too old' can be implied except through\nknowledge of the routing protocol by which the route\nwas learned.")
mplsL3VpnVrfRteInetCidrNextHopAS = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 11), InetAutonomousSystemNumber().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrNextHopAS.setDescription("The Autonomous System Number of the next hop.  The\nsemantics of this object are determined by the\nrouting protocol specified in the route's\nmplsL3VpnVrfRteInetCidrProto value.  When this\nobject is unknown or not relevant, its value should\nbe set to zero.")
mplsL3VpnVrfRteInetCidrMetric1 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrMetric1.setDescription("The primary routing metric for this route.  The\nsemantics of this metric are determined by the\n\n\n\nrouting protocol specified in the route's\nmplsL3VpnVrfRteInetCidrProto value.  If this\nmetric is not used, its value should be set to\n-1.")
mplsL3VpnVrfRteInetCidrMetric2 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrMetric2.setDescription("An alternate routing metric for this route.  The\nsemantics of this metric are determined by the routing\nprotocol specified in the route's\nmplsL3VpnVrfRteInetCidrProto\nvalue.  If this metric is not used, its value should be\nset to -1.")
mplsL3VpnVrfRteInetCidrMetric3 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrMetric3.setDescription("An alternate routing metric for this route.  The\nsemantics of this metric are determined by the routing\nprotocol specified in the route's\nmplsL3VpnVrfRteInetCidrProto\nvalue.  If this metric is not used, its value should be\nset to -1.")
mplsL3VpnVrfRteInetCidrMetric4 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrMetric4.setDescription("An alternate routing metric for this route.  The\nsemantics of this metric are determined by the routing\nprotocol specified in the route's\nmplsL3VpnVrfRteInetCidrProto value.  If this metric\nis not used, its value should be set to -1.")
mplsL3VpnVrfRteInetCidrMetric5 = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrMetric5.setDescription("An alternate routing metric for this route.  The\nsemantics of this metric are determined by the routing\nprotocol specified in the route's\nmplsL3VpnVrfRteInetCidrProto value.  If this metric is\nnot used, its value should be set to -1.")
mplsL3VpnVrfRteXCPointer = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 17), MplsIndexType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteXCPointer.setDescription("Index into mplsXCTable that identifies which cross-\nconnect entry is associated with this VRF route entry\nby containing the mplsXCIndex of that cross-connect entry.\nThe string containing the single-octet 0x00 indicates that\na label stack is not associated with this route entry.  This\ncan be the case because the label bindings have not yet\nbeen established, or because some change in the agent has\nremoved them.\n\nWhen the label stack associated with this VRF route is created,\nit MUST establish the associated cross-connect\nentry in the mplsXCTable and then set that index to the value\nof this object.  Changes to the cross-connect object in the\nmplsXCTable MUST automatically be reflected in the value of\nthis object.  If this object represents a static routing entry,\nthen the manager must ensure that this entry is maintained\nconsistently in the corresponding mplsXCTable as well.")
mplsL3VpnVrfRteInetCidrStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 11, 1, 4, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsL3VpnVrfRteInetCidrStatus.setDescription("The row status variable, used according to row\ninstallation and removal conventions.\n\n\n\nA row entry cannot be modified when the status is\nmarked as active(1).")
mplsL3VpnConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 2))
mplsL3VpnGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1))
mplsL3VpnCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 2))

# Augmentions
mplsL3VpnVrfEntry.registerAugmentions(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfEntry"))
mplsL3VpnVrfPerfEntry.setIndexNames(*mplsL3VpnVrfEntry.getIndexNames())
mplsL3VpnVrfEntry.registerAugmentions(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfSecEntry"))
mplsL3VpnVrfSecEntry.setIndexNames(*mplsL3VpnVrfEntry.getIndexNames())

# Notifications

mplsL3VpnVrfUp = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 11, 0, 1)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfConfRowStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfOperStatus"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfUp.setDescription("This notification is generated when:\na. No interface is associated with this VRF, and the first\n   (and only first) interface associated with it has its\n   ifOperStatus change to up(1).\n\nb. One interface is associated with this VRF, and\n   the ifOperStatus of this interface changes to up(1).\n\nc. Multiple interfaces are associated with this VRF, and the\n   ifOperStatus of all interfaces is down(2), and the first\n   of those interfaces has its ifOperStatus change to up(1).")
mplsL3VpnVrfDown = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 11, 0, 2)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfConfRowStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfOperStatus"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfDown.setDescription("This notification is generated when:\na. One interface is associated with this VRF, and\n   the ifOperStatus of this interface changes from up(1)\n   to down(2).\n\nb. Multiple interfaces are associated with this VRF, and\n   the ifOperStatus of all except one of these interfaces is\n   equal to up(1), and the ifOperStatus of that interface\n   changes from up(1) to down(2).\n\nc. The last interface with ifOperStatus equal to up(1)\n   is disassociated from a VRF.")
mplsL3VpnVrfRouteMidThreshExceeded = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 11, 0, 3)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfMidRteThresh"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfCurrNumRoutes"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfRouteMidThreshExceeded.setDescription("This notification is generated when the number of routes\ncontained by the specified VRF exceeds the value indicated by\nmplsL3VpnVrfMidRouteThreshold.  A single notification MUST be\ngenerated when this threshold is exceeded, and no other\nnotifications of this type should be issued until the value\nof mplsL3VpnVrfPerfCurrNumRoutes has fallen below that of\nmplsL3VpnVrfConfMidRteThresh.")
mplsL3VpnVrfNumVrfRouteMaxThreshExceeded = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 11, 0, 4)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfHighRteThresh"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfCurrNumRoutes"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfNumVrfRouteMaxThreshExceeded.setDescription("This notification is generated when the number of routes\ncontained by the specified VRF exceeds or attempts to exceed\nthe maximum allowed value as indicated by\nmplsL3VpnVrfMaxRouteThreshold.  In cases where\nmplsL3VpnVrfConfHighRteThresh is set to the same value\nas mplsL3VpnVrfConfMaxRoutes, mplsL3VpnVrfConfHighRteThresh\nneed not be exceeded; rather, just reached for this notification\nto be issued.\n\nNote that mplsL3VpnVrfConfRteMxThrshTime denotes the interval\nat which the this notification will be reissued after the\nmaximum value has been exceeded (or reached if\nmplsL3VpnVrfConfMaxRoutes and mplsL3VpnVrfConfHighRteThresh are\nequal) and the initial notification has been issued.  This value\nis intended to prevent continuous generation of notifications by\nan agent in the event that routes are continually added to a VRF\nafter it has reached its maximum value.  The default value is 0\nminutes.  If this value is set to 0, the agent should only issue\na single notification at the time that the maximum threshold has\nbeen reached, and should not issue any more notifications until\nthe value of routes has fallen below the configured threshold\nvalue.")
mplsL3VpnNumVrfSecIllglLblThrshExcd = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 11, 0, 5)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfSecIllegalLblVltns"), ) )
if mibBuilder.loadTexts: mplsL3VpnNumVrfSecIllglLblThrshExcd.setDescription("This notification is generated when the number of illegal\nlabel violations on a VRF as indicated by\n\n\n\nmplsL3VpnVrfSecIllegalLblVltns has exceeded\nmplsL3VpnIllLblRcvThrsh.  The threshold is not\nincluded in the varbind here because the value of\nmplsL3VpnVrfSecIllegalLblVltns should be one greater than\nthe threshold at the time this notification is issued.")
mplsL3VpnNumVrfRouteMaxThreshCleared = NotificationType((1, 3, 6, 1, 2, 1, 10, 166, 11, 0, 6)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfHighRteThresh"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfCurrNumRoutes"), ) )
if mibBuilder.loadTexts: mplsL3VpnNumVrfRouteMaxThreshCleared.setDescription("This notification is generated only after the number of routes\ncontained by the specified VRF exceeds or attempts to exceed\nthe maximum allowed value as indicated by\nmplsVrfMaxRouteThreshold, and then falls below this value.  The\nemission of this notification informs the operator that the\nerror condition has been cleared without the operator having to\nquery the device.\n\nNote that mplsL3VpnVrfConfRteMxThrshTime denotes the interval at\nwhich the mplsNumVrfRouteMaxThreshExceeded notification will\nbe reissued after the maximum value has been exceeded (or\nreached if mplsL3VpnVrfConfMaxRoutes and\nmplsL3VpnVrfConfHighRteThresh are equal) and the initial\nnotification has been issued.  Therefore,\nthe generation of this notification should also be emitted with\nthis same frequency (assuming that the error condition is\ncleared).  Specifically, if the error condition is reached and\ncleared several times during the period of time specified in\nmplsL3VpnVrfConfRteMxThrshTime, only a single notification will\nbe issued to indicate the first instance of the error condition\nas well as the first time the error condition is cleared.\nThis behavior is intended to prevent continuous generation of\nnotifications by an agent in the event that routes are\ncontinually added and removed to/from a VRF after it has\nreached its maximum value.  The default value is 0.  If this\nvalue is set to 0, the agent should issue a notification\nwhenever the maximum threshold has been cleared.")

# Groups

mplsL3VpnScalarGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 1)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfRteMxThrshTime"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnNotificationEnable"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnActiveVrfs"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfMaxPossRts"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnConfiguredVrfs"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnIllLblRcvThrsh"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnConnectedInterfaces"), ) )
if mibBuilder.loadTexts: mplsL3VpnScalarGroup.setDescription("Collection of scalar objects required for MPLS VPN\nmanagement.")
mplsL3VpnVrfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 2)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfVpnId"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfLastChanged"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRD"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfActiveInterfaces"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfMaxRoutes"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfStorageType"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfDescription"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfHighRteThresh"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfRowStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfAdminStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfOperStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfConfMidRteThresh"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfCreationTime"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfAssociatedInterfaces"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfGroup.setDescription("Collection of objects needed for MPLS VPN VRF\nmanagement.")
mplsL3VpnIfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 3)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfVpnClassification"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfVpnRouteDistProtocol"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfConfRowStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfConfStorageType"), ) )
if mibBuilder.loadTexts: mplsL3VpnIfGroup.setDescription("Collection of objects needed for MPLS VPN interface\nmanagement.")
mplsL3VpnPerfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 4)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfCurrNumRoutes"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfRoutesAdded"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfRoutesDeleted"), ) )
if mibBuilder.loadTexts: mplsL3VpnPerfGroup.setDescription("Collection of objects needed for MPLS VPN\nperformance information.")
mplsL3VpnPerfRouteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 5)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfRoutesDropped"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfPerfDiscTime"), ) )
if mibBuilder.loadTexts: mplsL3VpnPerfRouteGroup.setDescription("Collection of objects needed to track MPLS VPN\nrouting table dropped routes.")
mplsL3VpnSecGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 7)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfSecDiscontinuityTime"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfSecIllegalLblVltns"), ) )
if mibBuilder.loadTexts: mplsL3VpnSecGroup.setDescription("Collection of objects needed for MPLS VPN\nsecurity-related information.")
mplsL3VpnVrfRteGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 8)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrIfIndex"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrNextHopAS"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteXCPointer"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrAge"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrMetric4"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrMetric5"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrMetric2"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrMetric3"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrMetric1"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrType"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrProto"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteInetCidrStatus"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfRteGroup.setDescription("Objects required for VRF route table management.")
mplsL3VpnVrfRTGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 9)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTStorageType"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTRowStatus"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTDescr"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRT"), ) )
if mibBuilder.loadTexts: mplsL3VpnVrfRTGroup.setDescription("Objects required for VRF route target management.")
mplsL3VpnNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 1, 10)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnNumVrfRouteMaxThreshCleared"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfDown"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfUp"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRouteMidThreshExceeded"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfNumVrfRouteMaxThreshExceeded"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnNumVrfSecIllglLblThrshExcd"), ) )
if mibBuilder.loadTexts: mplsL3VpnNotificationGroup.setDescription("Objects required for MPLS VPN notifications.")

# Compliances

mplsL3VpnModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 2, 1)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnScalarGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnPerfGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnSecGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnNotificationGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnPerfRouteGroup"), ) )
if mibBuilder.loadTexts: mplsL3VpnModuleFullCompliance.setDescription("Compliance statement for agents that provide full support\nfor the MPLS-L3VPN-STD-MIB")
mplsL3VpnModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 11, 2, 2, 2)).setObjects(*(("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRTGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnScalarGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnPerfGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnSecGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnVrfRteGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnNotificationGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnIfGroup"), ("MPLS-L3VPN-STD-MIB", "mplsL3VpnPerfRouteGroup"), ) )
if mibBuilder.loadTexts: mplsL3VpnModuleReadOnlyCompliance.setDescription("Compliance requirement for implementations that only\nprovide read-only support for MPLS-L3VPN-STD-MIB.\nSuch devices can then be monitored but cannot be\nconfigured using this MIB module.")

# Exports

# Module identity
mibBuilder.exportSymbols("MPLS-L3VPN-STD-MIB", PYSNMP_MODULE_ID=mplsL3VpnMIB)

# Types
mibBuilder.exportSymbols("MPLS-L3VPN-STD-MIB", MplsL3VpnName=MplsL3VpnName, MplsL3VpnRouteDistinguisher=MplsL3VpnRouteDistinguisher, MplsL3VpnRtType=MplsL3VpnRtType)

# Objects
mibBuilder.exportSymbols("MPLS-L3VPN-STD-MIB", mplsL3VpnMIB=mplsL3VpnMIB, mplsL3VpnNotifications=mplsL3VpnNotifications, mplsL3VpnObjects=mplsL3VpnObjects, mplsL3VpnScalars=mplsL3VpnScalars, mplsL3VpnConfiguredVrfs=mplsL3VpnConfiguredVrfs, mplsL3VpnActiveVrfs=mplsL3VpnActiveVrfs, mplsL3VpnConnectedInterfaces=mplsL3VpnConnectedInterfaces, mplsL3VpnNotificationEnable=mplsL3VpnNotificationEnable, mplsL3VpnVrfConfMaxPossRts=mplsL3VpnVrfConfMaxPossRts, mplsL3VpnVrfConfRteMxThrshTime=mplsL3VpnVrfConfRteMxThrshTime, mplsL3VpnIllLblRcvThrsh=mplsL3VpnIllLblRcvThrsh, mplsL3VpnConf=mplsL3VpnConf, mplsL3VpnIfConfTable=mplsL3VpnIfConfTable, mplsL3VpnIfConfEntry=mplsL3VpnIfConfEntry, mplsL3VpnIfConfIndex=mplsL3VpnIfConfIndex, mplsL3VpnIfVpnClassification=mplsL3VpnIfVpnClassification, mplsL3VpnIfVpnRouteDistProtocol=mplsL3VpnIfVpnRouteDistProtocol, mplsL3VpnIfConfStorageType=mplsL3VpnIfConfStorageType, mplsL3VpnIfConfRowStatus=mplsL3VpnIfConfRowStatus, mplsL3VpnVrfTable=mplsL3VpnVrfTable, mplsL3VpnVrfEntry=mplsL3VpnVrfEntry, mplsL3VpnVrfName=mplsL3VpnVrfName, mplsL3VpnVrfVpnId=mplsL3VpnVrfVpnId, mplsL3VpnVrfDescription=mplsL3VpnVrfDescription, mplsL3VpnVrfRD=mplsL3VpnVrfRD, mplsL3VpnVrfCreationTime=mplsL3VpnVrfCreationTime, mplsL3VpnVrfOperStatus=mplsL3VpnVrfOperStatus, mplsL3VpnVrfActiveInterfaces=mplsL3VpnVrfActiveInterfaces, mplsL3VpnVrfAssociatedInterfaces=mplsL3VpnVrfAssociatedInterfaces, mplsL3VpnVrfConfMidRteThresh=mplsL3VpnVrfConfMidRteThresh, mplsL3VpnVrfConfHighRteThresh=mplsL3VpnVrfConfHighRteThresh, mplsL3VpnVrfConfMaxRoutes=mplsL3VpnVrfConfMaxRoutes, mplsL3VpnVrfConfLastChanged=mplsL3VpnVrfConfLastChanged, mplsL3VpnVrfConfRowStatus=mplsL3VpnVrfConfRowStatus, mplsL3VpnVrfConfAdminStatus=mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfStorageType=mplsL3VpnVrfConfStorageType, mplsL3VpnVrfRTTable=mplsL3VpnVrfRTTable, mplsL3VpnVrfRTEntry=mplsL3VpnVrfRTEntry, mplsL3VpnVrfRTIndex=mplsL3VpnVrfRTIndex, mplsL3VpnVrfRTType=mplsL3VpnVrfRTType, mplsL3VpnVrfRT=mplsL3VpnVrfRT, mplsL3VpnVrfRTDescr=mplsL3VpnVrfRTDescr, mplsL3VpnVrfRTRowStatus=mplsL3VpnVrfRTRowStatus, mplsL3VpnVrfRTStorageType=mplsL3VpnVrfRTStorageType, mplsL3VpnVrfSecTable=mplsL3VpnVrfSecTable, mplsL3VpnVrfSecEntry=mplsL3VpnVrfSecEntry, mplsL3VpnVrfSecIllegalLblVltns=mplsL3VpnVrfSecIllegalLblVltns, mplsL3VpnVrfSecDiscontinuityTime=mplsL3VpnVrfSecDiscontinuityTime, mplsL3VpnPerf=mplsL3VpnPerf, mplsL3VpnVrfPerfTable=mplsL3VpnVrfPerfTable, mplsL3VpnVrfPerfEntry=mplsL3VpnVrfPerfEntry, mplsL3VpnVrfPerfRoutesAdded=mplsL3VpnVrfPerfRoutesAdded, mplsL3VpnVrfPerfRoutesDeleted=mplsL3VpnVrfPerfRoutesDeleted, mplsL3VpnVrfPerfCurrNumRoutes=mplsL3VpnVrfPerfCurrNumRoutes, mplsL3VpnVrfPerfRoutesDropped=mplsL3VpnVrfPerfRoutesDropped, mplsL3VpnVrfPerfDiscTime=mplsL3VpnVrfPerfDiscTime, mplsL3VpnRoute=mplsL3VpnRoute, mplsL3VpnVrfRteTable=mplsL3VpnVrfRteTable, mplsL3VpnVrfRteEntry=mplsL3VpnVrfRteEntry, mplsL3VpnVrfRteInetCidrDestType=mplsL3VpnVrfRteInetCidrDestType, mplsL3VpnVrfRteInetCidrDest=mplsL3VpnVrfRteInetCidrDest, mplsL3VpnVrfRteInetCidrPfxLen=mplsL3VpnVrfRteInetCidrPfxLen, mplsL3VpnVrfRteInetCidrPolicy=mplsL3VpnVrfRteInetCidrPolicy, mplsL3VpnVrfRteInetCidrNHopType=mplsL3VpnVrfRteInetCidrNHopType, mplsL3VpnVrfRteInetCidrNextHop=mplsL3VpnVrfRteInetCidrNextHop, mplsL3VpnVrfRteInetCidrIfIndex=mplsL3VpnVrfRteInetCidrIfIndex, mplsL3VpnVrfRteInetCidrType=mplsL3VpnVrfRteInetCidrType, mplsL3VpnVrfRteInetCidrProto=mplsL3VpnVrfRteInetCidrProto, mplsL3VpnVrfRteInetCidrAge=mplsL3VpnVrfRteInetCidrAge, mplsL3VpnVrfRteInetCidrNextHopAS=mplsL3VpnVrfRteInetCidrNextHopAS, mplsL3VpnVrfRteInetCidrMetric1=mplsL3VpnVrfRteInetCidrMetric1, mplsL3VpnVrfRteInetCidrMetric2=mplsL3VpnVrfRteInetCidrMetric2, mplsL3VpnVrfRteInetCidrMetric3=mplsL3VpnVrfRteInetCidrMetric3, mplsL3VpnVrfRteInetCidrMetric4=mplsL3VpnVrfRteInetCidrMetric4, mplsL3VpnVrfRteInetCidrMetric5=mplsL3VpnVrfRteInetCidrMetric5, mplsL3VpnVrfRteXCPointer=mplsL3VpnVrfRteXCPointer, mplsL3VpnVrfRteInetCidrStatus=mplsL3VpnVrfRteInetCidrStatus, mplsL3VpnConformance=mplsL3VpnConformance, mplsL3VpnGroups=mplsL3VpnGroups, mplsL3VpnCompliances=mplsL3VpnCompliances)

# Notifications
mibBuilder.exportSymbols("MPLS-L3VPN-STD-MIB", mplsL3VpnVrfUp=mplsL3VpnVrfUp, mplsL3VpnVrfDown=mplsL3VpnVrfDown, mplsL3VpnVrfRouteMidThreshExceeded=mplsL3VpnVrfRouteMidThreshExceeded, mplsL3VpnVrfNumVrfRouteMaxThreshExceeded=mplsL3VpnVrfNumVrfRouteMaxThreshExceeded, mplsL3VpnNumVrfSecIllglLblThrshExcd=mplsL3VpnNumVrfSecIllglLblThrshExcd, mplsL3VpnNumVrfRouteMaxThreshCleared=mplsL3VpnNumVrfRouteMaxThreshCleared)

# Groups
mibBuilder.exportSymbols("MPLS-L3VPN-STD-MIB", mplsL3VpnScalarGroup=mplsL3VpnScalarGroup, mplsL3VpnVrfGroup=mplsL3VpnVrfGroup, mplsL3VpnIfGroup=mplsL3VpnIfGroup, mplsL3VpnPerfGroup=mplsL3VpnPerfGroup, mplsL3VpnPerfRouteGroup=mplsL3VpnPerfRouteGroup, mplsL3VpnSecGroup=mplsL3VpnSecGroup, mplsL3VpnVrfRteGroup=mplsL3VpnVrfRteGroup, mplsL3VpnVrfRTGroup=mplsL3VpnVrfRTGroup, mplsL3VpnNotificationGroup=mplsL3VpnNotificationGroup)

# Compliances
mibBuilder.exportSymbols("MPLS-L3VPN-STD-MIB", mplsL3VpnModuleFullCompliance=mplsL3VpnModuleFullCompliance, mplsL3VpnModuleReadOnlyCompliance=mplsL3VpnModuleReadOnlyCompliance)
