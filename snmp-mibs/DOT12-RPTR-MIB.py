# PySNMP SMI module. Autogenerated from smidump -f python DOT12-RPTR-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:37 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( snmpRptrGrpRptrAddrSearch, ) = mibBuilder.importSymbols("SNMP-REPEATER-MIB", "snmpRptrGrpRptrAddrSearch")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Counter64, Integer32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, mib_2, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "mib-2")
( MacAddress, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TimeStamp", "TruthValue")

# Objects

vgRptrMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 53)).setRevisions(("1997-05-19 22:56",))
if mibBuilder.loadTexts: vgRptrMIB.setOrganization("IETF 100VG-AnyLAN Working Group")
if mibBuilder.loadTexts: vgRptrMIB.setContactInfo("WG E-mail: vgmib@hprnd.rose.hp.com\n\nChair: Jeff Johnson\nPostal: RedBack Networks\n       2570 North First Street, Suite 410\n       San Jose, CA  95131\n  Tel: +1 408 571 2699\n  Fax: +1 408 571 2698\nE-mail: jeff@redbacknetworks.com\n\nEditor: John Flick\nPostal: Hewlett Packard Company\n       8000 Foothills Blvd. M/S 5556\n       Roseville, CA 95747-5556\n  Tel: +1 916 785 4018\n  Fax: +1 916 785 3583\nE-mail: johnf@hprnd.rose.hp.com")
if mibBuilder.loadTexts: vgRptrMIB.setDescription("This MIB module describes objects for managing\nIEEE 802.12 repeaters.")
vgRptrObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1))
vgRptrBasic = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1))
vgRptrBasicRptr = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1, 1))
vgRptrInfoTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1))
if mibBuilder.loadTexts: vgRptrInfoTable.setDescription("A table of information about each 802.12 repeater\nin the managed system.")
vgRptrInfoEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1)).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrInfoIndex"))
if mibBuilder.loadTexts: vgRptrInfoEntry.setDescription("An entry in the table, containing information\nabout a single repeater.")
vgRptrInfoIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: vgRptrInfoIndex.setDescription("A unique identifier for the repeater for which\nthis entry contains information.  The numbering\nscheme for repeaters is implementation specific.")
vgRptrInfoMACAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoMACAddress.setDescription("The MAC address used by the repeater when it\ninitiates training on the uplink port.  Repeaters\nare allowed to train with an assigned MAC address\nor a null (all zeroes) MAC address.")
vgRptrInfoCurrentFramingType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoCurrentFramingType.setDescription("The type of framing (802.3 or 802.5) currently\nin use by the repeater.")
vgRptrInfoDesiredFramingType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrInfoDesiredFramingType.setDescription("The type of framing which will be used by the\nrepeater after the next time it is reset.\n\nThe value of this object should be preserved\nacross repeater resets and power failures.")
vgRptrInfoFramingCapability = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("frameType88023", 1), ("frameType88025", 2), ("frameTypeEither", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoFramingCapability.setDescription("The type of framing this repeater is capable of\nsupporting.")
vgRptrInfoTrainingVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoTrainingVersion.setDescription("The highest version bits (vvv bits) supported by\nthe repeater during training.")
vgRptrInfoOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("other", 1), ("ok", 2), ("generalFailure", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoOperStatus.setDescription("The vgRptrInfoOperStatus object indicates the\noperational state of the repeater.")
vgRptrInfoReset = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("noReset", 1), ("reset", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrInfoReset.setDescription("Setting this object to reset(2) causes the\nrepeater to transition to its initial state as\nspecified in clause 12 [IEEE Std 802.12].\nSetting this object to noReset(1) has no effect.\nThe agent will always return the value noReset(1)\nwhen this object is read.\n\nAfter receiving a request to set this variable to\nreset(2), the agent is allowed to delay the reset\nfor a short period.  For example, the implementor\nmay choose to delay the reset long enough to\nallow the SNMP response to be transmitted.  In\nany event, the SNMP response must be transmitted.\n\nThis action does not reset the management\ncounters defined in this document nor does it\naffect the vgRptrPortAdminStatus parameters.\nIncluded in this action is the execution of a\ndisruptive Self-Test with the following\ncharacteristics:\n\n    1) The nature of the tests is not specified.\n    2) The test resets the repeater but without\n       affecting configurable management\n       information about the repeater.\n    3) Packets received during the test may or\n       may not be transferred.\n    4) The test does not interfere with\n       management functions.\n\nAfter performing this self-test, the agent will\nupdate the repeater health information (including\nvgRptrInfoOperStatus), and send a\nvgRptrResetEvent.")
vgRptrInfoLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 1, 1, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrInfoLastChange.setDescription("The value of sysUpTime when any of the following\nconditions occurred:\n\n    1) agent cold- or warm-started;\n    2) this instance of repeater was created\n       (such as when a device or module was\n       added to the system);\n    3) a change in the value of\n       vgRptrInfoOperStatus;\n    4) ports were added or removed as members of\n       the repeater; or\n    5) any of the counters associated with this\n       repeater had a discontinuity.")
vgRptrBasicGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1, 2))
vgRptrBasicGroupTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1))
if mibBuilder.loadTexts: vgRptrBasicGroupTable.setDescription("A table containing information about groups of\nports.")
vgRptrBasicGroupEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1)).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"))
if mibBuilder.loadTexts: vgRptrBasicGroupEntry.setDescription("An entry in the vgRptrBasicGroupTable, containing\ninformation about a single group of ports.")
vgRptrGroupIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2146483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: vgRptrGroupIndex.setDescription("This object identifies the group within the\nsystem for which this entry contains information.\nThe numbering scheme for groups is implementation\nspecific.")
vgRptrGroupObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrGroupObjectID.setDescription("The vendor's authoritative identification of the\ngroup.  This value may be allocated within the\nSMI enterprises subtree (1.3.6.1.4.1) and\nprovides a straight-forward and unambiguous means\nfor determining what kind of group is being\nmanaged.\n\nFor example, this object could take the value\n1.3.6.1.4.1.4242.1.2.14 if vendor 'Flintstones,\nInc.' was assigned the subtree 1.3.6.1.4.1.4242,\nand had assigned the identifier\n1.3.6.1.4.1.4242.1.2.14 to its 'Wilma Flintstone\n6-Port Plug-in Module.'")
vgRptrGroupOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(5,3,6,2,1,4,)).subtype(namedValues=NamedValues(("other", 1), ("operational", 2), ("malfunctioning", 3), ("notPresent", 4), ("underTest", 5), ("resetInProgress", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrGroupOperStatus.setDescription("An object that indicates the operational status\nof the group.\n\nA status of notPresent(4) indicates that the\ngroup is temporarily or permanently physically\nand/or logically not a part of the system.  It\nis an implementation-specific matter as to\nwhether the agent effectively removes notPresent\nentries from the table.\n\nA status of operational(2) indicates that the\ngroup is functioning, and a status of\nmalfunctioning(3) indicates that the group is\nmalfunctioning in some way.")
vgRptrGroupPortCapacity = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2146483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrGroupPortCapacity.setDescription("The vgRptrGroupPortCapacity is the number of\nports that can be contained within the group.\nValid range is 1-2147483647.  Within each group,\nthe ports are uniquely numbered in the range from\n1 to vgRptrGroupPortCapacity.\n\nSome ports may not be present in the system, in\nwhich case the actual number of ports present will\nbe less than the value of vgRptrGroupPortCapacity.\nThe number of ports present is never greater than\nthe value of vgRptrGroupPortCapacity.\n\nNote:  In practice, this will generally be the\nnumber of ports on a module, card, or board, and\nthe port numbers will correspond to numbers marked\non the physical embodiment.")
vgRptrGroupCablesBundled = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 2, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("someCablesBundled", 1), ("noCablesBundled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrGroupCablesBundled.setDescription("This object is used to indicate whether there are\nany four-pair UTP links connected to this group\nthat are contained in a cable bundle with multiple\nfour-pair groups (e.g. a 25-pair bundle).  Bundled\ncable may only be used for repeater-to-end node\nlinks where the end node is not in promiscuous\nmode.\n\nWhen a broadcast or multicast packet is received\nfrom a port on this group that is not a\npromiscuous or cascaded port, the packet will be\nbuffered completely before being repeated if\nthis object is set to 'someCablesBundled(1)'.\nWhen this object is equal to 'noCablesBundled(2)',\nall packets received from ports on this group will\nbe repeated as the frame is being received.\n\nNote that the value 'someCablesBundled(1)' will\nwork in the vast majority of all installations,\nregardless of whether or not any cables are\nphysically in a bundle, since packets received\nfrom promiscuous and cascaded ports automatically\navoid the store and forward.  The main situation\nin which 'noCablesBundled(2)' is beneficial is\nwhen there is a large amount of multicast traffic\nand the cables are not in a bundle.\n\nThe value of this object should be preserved\nacross repeater resets and power failures.")
vgRptrBasicPort = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 1, 3))
vgRptrBasicPortTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1))
if mibBuilder.loadTexts: vgRptrBasicPortTable.setDescription("A table containing configuration and status\ninformation about 802.12 repeater ports in the\nsystem.  The number of entries is independent of\nthe number of repeaters in the managed system.")
vgRptrBasicPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1)).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"), (0, "DOT12-RPTR-MIB", "vgRptrPortIndex"))
if mibBuilder.loadTexts: vgRptrBasicPortEntry.setDescription("An entry in the vgRptrBasicPortTable, containing\ninformation about a single port.")
vgRptrPortIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: vgRptrPortIndex.setDescription("This object identifies the port within the group\nfor which this entry contains information.  This\nidentifies the port independently from the\nrepeater it may be attached to.  The numbering\nscheme for ports is implementation specific;\nhowever, this value can never be greater than\nvgRptrGroupPortCapacity for the associated group.")
vgRptrPortType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(2,4,1,3,)).subtype(namedValues=NamedValues(("cascadeExternal", 1), ("cascadeInternal", 2), ("localExternal", 3), ("localInternal", 4), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortType.setDescription("Describes the type of port.  One of the\nfollowing:\n\n    cascadeExternal - Port is an uplink with\n                      physical connections which\n                      are externally visible\n    cascadeInternal - Port is an uplink with\n                      physical connections which\n                      are not externally visible,\n                      such as a connection to an\n                      internal backplane in a\n                      chassis\n    localExternal   - Port is a downlink or local\n                      port with externally\n                      visible connections\n    localInternal   - Port is a downlink or local\n                      port with connections which\n                      are not externally visible,\n                      such as a connection to an\n                      internal agent\n\n'internal' is used to identify ports which place\ntraffic into the repeater, but do not have any\nexternal connections.  Note that both DTE and\ncascaded repeater downlinks are considered\n'local' ports.")
vgRptrPortAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrPortAdminStatus.setDescription("Port enable/disable function.  Enabling a\ndisabled port will cause training to be\ninitiated by the training initiator (the slave\nmode device) on the link.  Setting this object to\ndisabled(2) disables the port.\n\nA disabled port neither transmits nor receives.\nOnce disabled, a port must be explicitly enabled\nto restore operation.  A port which is disabled\nwhen power is lost or when a reset is exerted\nshall remain disabled when normal operation\nresumes.\n\nThe value of this object should be preserved\nacross repeater resets and power failures.")
vgRptrPortOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(1,3,2,)).subtype(namedValues=NamedValues(("active", 1), ("inactive", 2), ("training", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortOperStatus.setDescription("Current status for the port as specified by the\nPORT_META_STATE in the port process module of\nclause 12 [IEEE Std 802.12].\n\nDuring initialization or any link warning\nconditions, vgRptrPortStatus will be\n'inactive(2)'.\n\nWhen Training_Up is received by the repeater on a\nlocal port (or when Training_Down is received on\na cascade port), vgRptrPortStatus will change to\n'training(3)' and vgRptrTrainingResult can be\nmonitored to see the detailed status regarding\ntraining.\n\nWhen 24 consecutive good FCS packets are exchanged\nand the configuration bits are OK,\nvgRptrPortStatus will change to 'active(1)'.\n\nA disabled port shall have a port status of\n'inactive(2)'.")
vgRptrPortSupportedPromiscMode = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("singleModeOnly", 1), ("singleOrPromiscMode", 2), ("promiscModeOnly", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortSupportedPromiscMode.setDescription("This object describes whether the port hardware\nis capable of supporting promiscuous mode, single\naddress mode (i.e., repeater filters unicasts not\naddressed to the end station attached to this\nport), or both.  A port for which vgRptrPortType\nis equal to 'cascadeInternal' or 'cascadeExternal'\nwill always have a value of 'promiscModeOnly' for\nthis object.")
vgRptrPortSupportedCascadeMode = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 6), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,3,)).subtype(namedValues=NamedValues(("endNodesOnly", 1), ("endNodesOrRepeaters", 2), ("cascadePort", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortSupportedCascadeMode.setDescription("This object describes whether the port hardware\nis capable of supporting cascaded repeaters, end\nnodes, or both.  A port for which vgRptrPortType\nis equal to 'cascadeInternal' or\n'cascadeExternal' will always have a value of\n'cascadePort' for this object.")
vgRptrPortAllowedTrainType = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(3,4,2,1,)).subtype(namedValues=NamedValues(("allowEndNodesOnly", 1), ("allowPromiscuousEndNodes", 2), ("allowEndNodesOrRepeaters", 3), ("allowAnything", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrPortAllowedTrainType.setDescription("This security object is set by the network\nmanager to configure what type of device is\npermitted to connect to the port.  One of the\nfollowing values:\n    allowEndNodesOnly        - only non-\n                               promiscuous end\n                               nodes permitted.\n    allowPromiscuousEndNodes - promiscuous or\n                               non-promiscuous\n                               end nodes\n                               permitted\n    allowEndNodesOrRepeaters - repeaters or non-\n                               promiscuous end\n                               nodes permitted\n    allowAnything            - repeaters,\n                               promiscuous or\n                               non-promiscuous\n                               end nodes\n                               permitted\n\nFor a port for which vgRptrPortType is equal to\n'cascadeInternal' or 'cascadeExternal', the\ncorresponding instance of this object may not be\nset to 'allowEndNodesOnly' or\n'allowPromiscuousEndNodes'.\n\nThe agent must reject a SET of this object if the\nvalue includes no capabilities that are\nsupported by this port's hardware, as defined by\nthe values of the corresponding instances of\nvgRptrPortSupportedPromiscMode and\nvgRptrPortSupportedCascadeMode.\n\nNote that vgRptrPortSupportPromiscMode and\nvgRptrPortSupportedCascadeMode represent what the\nport hardware is capable of supporting.\nvgRptrPortAllowedTrainType is used for setting an\nadministrative policy for a port.  The actual set\nof training configurations that will be allowed\nto succeed on a port is the intersection of what\nthe hardware will support and what is\nadministratively allowed.  The above requirement\non what values may be set to this object says that\nthe intersection of what is supported and what is\nallowed must be non-empty.  In other words, it\nmust not result in a situation in which nothing\nwould be allowed to train on that port.  However,\na value can be set to this object as long as the\ncombination of this object and what is supported\nby the hardware would still leave at least one\nconfiguration that could successfully train on the\nport.\nThe value of this object should be preserved\nacross repeater resets and power failures.")
vgRptrPortLastTrainConfig = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortLastTrainConfig.setDescription("This object is a 16 bit field.  For local ports,\nthis object contains the requested configuration\nfield from the most recent error-free training\nrequest frame sent by the device connected to\nthe port.  For cascade ports, this object contains\nthe responder's allowed configuration field from\nthe most recent error-free training response frame\nreceived in response to training initiated by this\nrepeater.  The format of the current version of\nthis field is described in section 3.2.  Please\nrefer to the most recent version of the IEEE\n802.12 standard for the most up-to-date definition\nof the format of this object.")
vgRptrPortTrainingResult = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortTrainingResult.setDescription("This 18 bit field is used to indicate the result\nof training.  It contains two bits which indicate\nif error-free training frames have been received,\nand it also contains the 16 bits of the allowed\nconfiguration field from the most recent\nerror-free training response frame on the port.\n\n  First Octet:    Second and Third Octets:\n  7 6 5 4 3 2 1 0\n +-+-+-+-+-+-+-+-+-----------------------------+\n |0|0|0|0|0|0|V|G| allowed configuration field |\n +-+-+-+-+-+-+-+-+-----------------------------+\n    V:   Valid: set when at least one error-free\n         training frame has been received.\n         Indicates the 16 training configuration\n         bits in vgRptrPortLastTrainConfig and\n         vgRptrPortTrainingResult contain valid\n         information.  This bit is cleared when\n         vgRptrPortStatus transitions to the\n         'inactive' or 'training' state.\n    G:   LinkGood: indicates the link hardware is\n         OK.  Set if 24 consecutive error-free\n         training packets have been exchanged.\n         Cleared when a training packet with\n         errors is received, or when\n         vgRptrPortStatus transitions to the\n         'inactive' or 'training' state.\n\nThe format of the current version of the allowed\nconfiguration field is described in section 3.2.\nPlease refer to the most recent version of the\nIEEE 802.12 standard for the most up-to-date\ndefinition of the format of this field.\n\nIf the port is in training, a management station\ncan examine this object to see if any training\npackets have been passed successfully.  If there\nhave been any good training packets, the Valid\nbit will be set and the management station can\nexamine the allowed configuration field to see if\nthere is a duplicate address, configuration, or\nsecurity problem.\n\nNote that on a repeater local port, this repeater\ngenerates the training response bits, while on\na cascade port, the device at the upper end of\nthe link originated the training response bits.")
vgRptrPortPriorityEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrPortPriorityEnable.setDescription("A configuration flag used to determine whether\nthe repeater will service high priority requests\nreceived on the port as high priority or normal\npriority.  When 'false', high priority requests\non this port will be serviced as normal priority.\n\nThe setting of this object has no effect on a\ncascade port.  Also note that the setting of this\nobject has no effect on a port connected to a\ncascaded repeater.  In both of these cases, this\nsetting is treated as always 'true'.  The value\n'false' only has an effect when the port is a\nlocalInternal or localExternal port connected to\nan end node.\n\nThe value of this object should be preserved\nacross repeater resets and power failures.")
vgRptrPortRptrInfoIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 1, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortRptrInfoIndex.setDescription("This object identifies the repeater that this\nport is currently mapped to.  The repeater\nidentified by a particular value of this object\nis the same as that identified by the same value\nof vgRptrInfoIndex.  A value of zero indicates\nthat this port is not currently mapped to any\nrepeater.")
vgRptrMonitor = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2))
vgRptrMonRepeater = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2, 1))
vgRptrMonitorTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1))
if mibBuilder.loadTexts: vgRptrMonitorTable.setDescription("A table of performance and error statistics for\neach repeater in the system.  The instance of the\nvgRptrInfoLastChange associated with a repeater\nis used to indicate possible discontinuities of\nthe counters in this table that are associated\nwith the same repeater.")
vgRptrMonitorEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1)).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrInfoIndex"))
if mibBuilder.loadTexts: vgRptrMonitorEntry.setDescription("An entry in the table, containing statistics\nfor a single repeater.")
vgRptrMonTotalReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonTotalReadableFrames.setDescription("The total number of good frames of valid frame\nlength that have been received on all ports in\nthis repeater.  If an implementation cannot\nobtain a count of frames as seen by the repeater\nitself, this counter may be implemented as the\nsummation of the values of the\nvgRptrPortReadableFrames counters for all of the\nports in this repeater.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrInfoLastChange changes.")
vgRptrMonTotalReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonTotalReadableOctets.setDescription("The total number of octets contained in good\nframes that have been received on all ports in\nthis repeater.  If an implementation cannot\nobtain a count of octets as seen by the repeater\nitself, this counter may be implemented as the\nsummation of the values of the\nvgRptrPortReadableOctets counters for all of the\nports in this repeater.\n\nNote that this counter can roll over very\nquickly.  A management station is advised to\nalso poll the vgRptrReadableOctetRollovers\nobject, or to use the 64-bit counter defined by\nvgRptrMonHCTotalReadableOctets instead of the\ntwo 32-bit counters.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrInfoLastChange changes.")
vgRptrMonReadableOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonReadableOctetRollovers.setDescription("The total number of times that the associated\ninstance of the vgRptrMonTotalReadableOctets\ncounter has rolled over.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrInfoLastChange changes.")
vgRptrMonHCTotalReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonHCTotalReadableOctets.setDescription("The total number of octets contained in good\nframes that have been received on all ports in\nthis repeater.  If an implementation cannot\nobtain a count of octets as seen by the repeater\nitself, this counter may be implemented as the\nsummation of the values of the\nvgRptrPortHCReadableOctets counters for all of the\nports in this repeater.\n\nThis counter is a 64 bit version of\nvgRptrMonTotalReadableOctets.  It should be used\nby Network Management protocols which support 64\nbit counters (e.g. SNMPv2).\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrInfoLastChange changes.")
vgRptrMonTotalErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrMonTotalErrors.setDescription("The total number of errors which have occurred on\nall of the ports in this repeater.  If an\nimplementation cannot obtain a count of these\nerrors as seen by the repeater itself, this\ncounter may be implemented as the summation of the\nvalues of the vgRptrPortIPMFrames,\nvgRptrPortOversizeFrames, and\nvgRptrPortDataErrorFrames counters for all of the\nports in this repeater.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrInfoLastChange changes.")
vgRptrMonGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2, 2))
vgRptrMonPort = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 2, 3))
vgRptrMonPortTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1))
if mibBuilder.loadTexts: vgRptrMonPortTable.setDescription("A table of performance and error statistics for\nthe ports.  The columnar object\nvgRptrPortLastChange is used to indicate possible\ndiscontinuities of counter type columnar objects\nin this table.")
vgRptrMonPortEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1)).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"), (0, "DOT12-RPTR-MIB", "vgRptrPortIndex"))
if mibBuilder.loadTexts: vgRptrMonPortEntry.setDescription("An entry in the vgRptrMonPortTable, containing\nperformance and error statistics for a single\nport.")
vgRptrPortReadableFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortReadableFrames.setDescription("This object is the number of good frames of\nvalid frame length that have been received on\nthis port.  This counter is incremented by one\nfor each frame received on the port which is not\ncounted by any of the following error counters:\nvgRptrPortIPMFrames, vgRptrPortOversizeFrames,\nvgRptrPortNullAddressedFrames, or\nvgRptrPortDataErrorFrames.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortReadableOctets.setDescription("This object is a count of the number of octets\ncontained in good frames that have been received\non this port.  This counter is incremented by\nOctetCount for each frame received on this port\nwhich has been determined to be a readable frame\n(i.e. each frame counted by\nvgRptrPortReadableFrames).\n\nNote that this counter can roll over very\nquickly.  A management station is advised to\nalso poll the vgRptrPortReadOctetRollovers\nobject, or to use the 64-bit counter defined by\nvgRptrPortHCReadableOctets instead of the two\n32-bit counters.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortReadOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortReadOctetRollovers.setDescription("This object is a count of the number of times\nthat the associated instance of the\nvgRptrPortReadableOctets counter has rolled over.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHCReadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCReadableOctets.setDescription("This object is a count of the number of octets\ncontained in good frames that have been received\non this port.  This counter is incremented by\nOctetCount for each frame received on this port\nwhich has been determined to be a readable frame\n(i.e. each frame counted by\nvgRptrPortReadableFrames).\n\nThis counter is a 64 bit version of\nvgRptrPortReadableOctets.  It should be used by\nNetwork Management protocols which support 64 bit\ncounters (e.g. SNMPv2).\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortUnreadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortUnreadableOctets.setDescription("This object is a count of the number of octets\ncontained in invalid frames that have been\nreceived on this port.  This counter is\nincremented by OctetCount for each frame received\non this port which is counted by\nvgRptrPortIPMFrames, vgRptrPortOversizeFrames,\nvgRptrPortNullAddressedFrames, or\nvgRptrPortDataErrorFrames.  This counter can be\ncombined with vgRptrPortReadableOctets to\ncalculate network utilization.\n\nNote that this counter can roll over very\nquickly.  A management station is advised to\nalso poll the vgRptrPortUnreadOctetRollovers\nobject, or to use the 64-bit counter defined by\nvgRptrPortHCUnreadableOctets instead of the two\n32-bit counters.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortUnreadOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortUnreadOctetRollovers.setDescription("This object is a count of the number of times\nthat the associated instance of the\nvgRptrPortUnreadableOctets counter has rolled\nover.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHCUnreadableOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCUnreadableOctets.setDescription("This object is a count of the number of octets\ncontained in invalid frames that have been\nreceived on this port.  This counter is\nincremented by OctetCount for each frame received\non this port which is counted by\nvgRptrPortIPMFrames, vgRptrPortOversizeFrames,\nvgRptrPortNullAddressedFrames, or\nvgRptrPortDataErrorFrames.  This counter can be\ncombined with vgRptrPortHCReadableOctets to\ncalculate network utilization.\n\nThis counter is a 64 bit version of\nvgRptrPortUnreadableOctets.  It should be used\nby Network Management protocols which support 64\nbit counters (e.g. SNMPv2).\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHighPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHighPriorityFrames.setDescription("This object is a count of high priority frames\nthat have been received on this port.  This\ncounter is incremented by one for each high\npriority frame received on this port.  This\ncounter includes both good and bad high priority\nframes, as well as high priority training frames.\nThis counter does not include normal priority\nframes which were priority promoted.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHighPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in high priority frames that have been\nreceived on this port.  This counter is\nincremented by OctetCount for each frame received\non this port which is counted by\nvgRptrPortHighPriorityFrames.\n\nNote that this counter can roll over very\nquickly.  A management station is advised to\nalso poll the vgRptrPortHighPriOctetRollovers\nobject, or to use the 64-bit counter defined by\nvgRptrPortHCHighPriorityOctets instead of the two\n32-bit counters.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHighPriOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHighPriOctetRollovers.setDescription("This object is a count of the number of times\nthat the associated instance of the\nvgRptrPortHighPriorityOctets counter has rolled\nover.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHCHighPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCHighPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in high priority frames that have been\nreceived on this port.  This counter is\nincremented by OctetCount for each frame received\non this port which is counted by\nvgRptrPortHighPriorityFrames.\n\nThis counter is a 64 bit version of\nvgRptrPortHighPriorityOctets.  It should be used\nby Network Management protocols which support\n64 bit counters (e.g. SNMPv2).\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortNormPriorityFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNormPriorityFrames.setDescription("This object is a count of normal priority frames\nthat have been received on this port.  This\ncounter is incremented by one for each normal\npriority frame received on this port. This\ncounter includes both good and bad normal\npriority frames, as well as normal priority\ntraining frames and normal priority frames which\nwere priority promoted.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNormPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in normal priority frames that have\nbeen received on this port.  This counter is\nincremented by OctetCount for each frame received\non this port which is counted by\nvgRptrPortNormPriorityFrames.\n\nNote that this counter can roll over very\nquickly.  A management station is advised to\nalso poll the vgRptrPortNormPriOctetRollovers\nobject, or to use the 64-bit counter defined by\nvgRptrPortHCNormPriorityOctets instead of the two\n32-bit counters.\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortNormPriOctetRollovers = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNormPriOctetRollovers.setDescription("This object is a count of the number of times\nthat the associated instance of the\nvgRptrPortNormPriorityOctets counter has rolled\nover.\n\nThis two-counter mechanism is provided for those\nnetwork management protocols that do not support\n64-bit counters (e.g. SNMPv1).  Note that\nretrieval of these two counters in the same PDU\nis NOT guaranteed to be atomic.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortHCNormPriorityOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortHCNormPriorityOctets.setDescription("This object is a count of the number of octets\ncontained in normal priority frames that have\nbeen received on this port.  This counter is\nincremented by OctetCount for each frame received\non this port which is counted by\nvgRptrPortNormPriorityFrames.\n\nThis counter is a 64 bit version of\nvgRptrPortNormPriorityOctets.  It should be used\nby Network Management protocols which support\n64 bit counters (e.g. SNMPv2).\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortBroadcastFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortBroadcastFrames.setDescription("This object is a count of broadcast packets that\nhave been received on this port.  This counter is\nincremented by one for each readable frame\nreceived on this port whose destination MAC\naddress is the broadcast address.  Frames\ncounted by this counter are also counted by\nvgRptrPortReadableFrames.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortMulticastFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortMulticastFrames.setDescription("This object is a count of multicast packets that\nhave been received on this port.  This counter is\nincremented by one for each readable frame\nreceived on this port whose destination MAC\naddress has the group address bit set, but is not\nthe broadcast address.  Frames counted by this\ncounter are also counted by\nvgRptrPortReadableFrames, but not by\nvgRptrPortBroadcastFrames.  Note that when the\nvalue of the instance vgRptrInfoCurrentFramingType\nfor the repeater that this port is associated\nwith is equal to 'frameType88025', this count\nincludes packets addressed to functional\naddresses.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortNullAddressedFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortNullAddressedFrames.setDescription("This object is a count of null addressed packets\nthat have been received on this port.  This\ncounter is incremented by one for each frame\nreceived on this port with a destination MAC\naddress consisting of all zero bits.  Both void\nand training frames are included in this\ncounter.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortIPMFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortIPMFrames.setDescription("This object is a count of the number of frames\nthat have been received on this port with an\ninvalid packet marker and no PMI errors.  A\nrepeater will write an invalid packet marker to\nthe end of a frame containing errors as it is\nforwarded through the repeater to the other\nports.  This counter is incremented by one for\neach frame received on this port which has had an\ninvalid packet marker added to the end of the\nframe.\n\nThis counter indicates problems occurring in the\ndomain of other repeaters, as opposed to problems\nwith cables or devices directly attached to this\nrepeater.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortOversizeFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortOversizeFrames.setDescription("This object is a count of oversize frames\nreceived on this port.  This counter is\nincremented by one for each frame received on\nthis port whose OctetCount is larger than the\nmaximum legal frame size.\n\nThe frame size which causes this counter to\nincrement is dependent on the current value of\nvgRptrInfoCurrentFramingType for the repeater that\nthe port is associated with.  When\nvgRptrInfoCurrentFramingType is equal to\nframeType88023 this counter will increment for\nframes that are 1519 octets or larger.  When\nvgRptrInfoCurrentFramingType is equal to\nframeType88025 this counter will increment for\nframes that are 4521 octets or larger.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortDataErrorFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortDataErrorFrames.setDescription("This object is a count of errored frames\nreceived on this port.  This counter is\nincremented by one for each frame received on\nthis port with any of the following errors: bad\nFCS (with no IPM), PMI errors (excluding frames\nwith an IPM error as the only PMI error), or\nundersize (with no IPM).  Does not include\npackets counted by vgRptrPortIPMFrames,\nvgRptrPortOversizeFrames, or\nvgRptrPortNullAddressedFrames.\n\nThis counter indicates problems with cables or\ndevices directly connected to this repeater, while\nvgRptrPortIPMFrames indicates problems occurring\nin the domain of other repeaters.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortPriorityPromotions = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortPriorityPromotions.setDescription("This counter is incremented by one each time the\npriority promotion timer has expired on this port\nand a normal priority frame is priority\npromoted.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortTransitionToTrainings = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortTransitionToTrainings.setDescription("This counter is incremented by one each time the\nvgRptrPortStatus object for this port transitions\ninto the 'training' state.\n\nThis counter may experience a discontinuity when\nthe value of the corresponding instance of\nvgRptrPortLastChange changes.")
vgRptrPortLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 2, 3, 1, 1, 24), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrPortLastChange.setDescription("The value of sysUpTime when the last of the\nfollowing occurred:\n  1) the agent cold- or warm-started;\n  2) the row for the port was created\n     (such as when a device or module was\n     added to the system); or\n  3) any condition that would cause one of\n     the counters for the row to experience\n     a discontinuity.")
vgRptrAddrTrack = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3))
vgRptrAddrTrackRptr = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3, 1))
vgRptrAddrTrackGroup = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3, 2))
vgRptrAddrTrackPort = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 1, 3, 3))
vgRptrAddrTrackTable = MibTable((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1))
if mibBuilder.loadTexts: vgRptrAddrTrackTable.setDescription("Table of address mapping information about the\nports.")
vgRptrAddrTrackEntry = MibTableRow((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1)).setIndexNames((0, "DOT12-RPTR-MIB", "vgRptrGroupIndex"), (0, "DOT12-RPTR-MIB", "vgRptrPortIndex"))
if mibBuilder.loadTexts: vgRptrAddrTrackEntry.setDescription("An entry in the table, containing address mapping\ninformation about a single port.")
vgRptrAddrLastTrainedAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 1), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0,0),ValueSizeConstraint(6,6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrAddrLastTrainedAddress.setDescription("This object is the MAC address of the last\nstation which succeeded in training on this port.\nA cascaded repeater may train using the null\naddress.  If no stations have succeeded in\ntraining on this port since the agent began\nmonitoring the port activity, the agent shall\nreturn a string of length zero.")
vgRptrAddrTrainedAddrChanges = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrAddrTrainedAddrChanges.setDescription("This counter is incremented by one for each time\nthat the vgRptrAddrLastTrainedAddress object for\nthis port changes.")
vgRptrRptrDetectedDupAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vgRptrRptrDetectedDupAddress.setDescription("This object is used to indicate that the\nrepeater detected an error-free training frame on\nthis port with a non-null source MAC address which\nmatches the value of vgRptrAddrLastTrainedAddress\nof another active port in the same repeater.  This\nis reset to 'false' when an error-free training\nframe is received with a non-null source MAC\naddress which does not match\nvgRptrAddrLastTrainedAddress of another port which\nis active in the same repeater.\n\nFor the cascade port, this object will be 'true'\nif the 'D' bit in the most recently received\nerror-free training response frame was set,\nindicating the device at the other end of the link\nbelieves that this repeater's cascade port is\nusing a duplicate address.  This may be because\nthe device at the other end of the link detected a\nduplicate address itself, or, if the other device\nis also a repeater, it could be because\nvgRptrMgrDetectedDupAddress was set to 'true' on\nthe port that this repeater's cascade port is\nconnected to.")
vgRptrMgrDetectedDupAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 53, 1, 3, 3, 1, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vgRptrMgrDetectedDupAddress.setDescription("This object can be set by a management station\nwhen it detects that there is a duplicate MAC\naddress.  This object is OR'd with\nvgRptrRptrDetectedDupAddress to form the value of\nthe 'D' bit in training response frames on this\nport.\n\nThe purpose of this object is to provide a means\nfor network management software to inform an end\nstation that it is using a duplicate station\naddress.  Setting this object does not affect the\ncurrent state of the link; the end station will\nnot be informed of the duplicate address until it\nretrains for some reason.  Note that regardless\nof its station address, the end station will not\nbe able to train successfully until the network\nmanagement software has set this object back to\n'false'.  Although this object exists on\ncascade ports, it does not perform any function\nsince this repeater is the initiator of training\non a cascade port.")
vgRptrTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 2))
vgRptrTrapPrefix = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 2, 0))
vgRptrConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 3))
vgRptrCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 3, 1))
vgRptrGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 53, 3, 2))

# Augmentions

# Notifications

vgRptrHealth = NotificationType((1, 3, 6, 1, 2, 1, 53, 2, 0, 1)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrInfoOperStatus"), ) )
if mibBuilder.loadTexts: vgRptrHealth.setDescription("A vgRptrHealth trap conveys information related\nto the operational state of a repeater.  This trap\nis sent when the value of an instance of\nvgRptrInfoOperStatus changes.  The vgRptrHealth\ntrap is not sent as a result of powering up a\nrepeater.\n\nThe vgRptrHealth trap must contain the instance of\nthe vgRptrInfoOperStatus object associated with\nthe affected repeater.\n\nThe agent must throttle the generation of\nconsecutive vgRptrHealth traps so that there is at\nleast a five-second gap between traps of this\ntype.  When traps are throttled, they are dropped,\nnot queued for sending at a future time.  (Note\nthat 'generating' a trap means sending to all\nconfigured recipients.)")
vgRptrResetEvent = NotificationType((1, 3, 6, 1, 2, 1, 53, 2, 0, 2)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrInfoOperStatus"), ) )
if mibBuilder.loadTexts: vgRptrResetEvent.setDescription("A vgRptrResetEvent trap conveys information\nrelated to the operational state of a repeater.\nThis trap is sent on completion of a repeater\nreset action.  A repeater reset action is defined\nas a transition to its initial state as specified\nin clause 12 [IEEE Std 802.12] when triggered by\na management command.\n\nThe vgRptrResetEvent trap is not sent when the\nagent restarts and sends an SNMP coldStart or\nwarmStart trap.\n\nThe vgRptrResetEvent trap must contain the\ninstance of the vgRptrInfoOperStatus object\nassociated with the affected repeater.\n\nThe agent must throttle the generation of\nconsecutive vgRptrResetEvent traps so that there\nis at least a five-second gap between traps of\nthis type.  When traps are throttled, they are\ndropped, not queued for sending at a future time.\n(Note that 'generating' a trap means sending to\nall configured recipients.)")

# Groups

vgRptrConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 1)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrPortAllowedTrainType"), ("DOT12-RPTR-MIB", "vgRptrGroupOperStatus"), ("DOT12-RPTR-MIB", "vgRptrInfoOperStatus"), ("DOT12-RPTR-MIB", "vgRptrPortType"), ("DOT12-RPTR-MIB", "vgRptrGroupPortCapacity"), ("DOT12-RPTR-MIB", "vgRptrInfoDesiredFramingType"), ("DOT12-RPTR-MIB", "vgRptrInfoFramingCapability"), ("DOT12-RPTR-MIB", "vgRptrPortRptrInfoIndex"), ("DOT12-RPTR-MIB", "vgRptrInfoCurrentFramingType"), ("DOT12-RPTR-MIB", "vgRptrPortLastTrainConfig"), ("DOT12-RPTR-MIB", "vgRptrInfoLastChange"), ("DOT12-RPTR-MIB", "vgRptrInfoTrainingVersion"), ("DOT12-RPTR-MIB", "vgRptrPortTrainingResult"), ("DOT12-RPTR-MIB", "vgRptrGroupCablesBundled"), ("DOT12-RPTR-MIB", "vgRptrPortAdminStatus"), ("DOT12-RPTR-MIB", "vgRptrPortOperStatus"), ("DOT12-RPTR-MIB", "vgRptrInfoReset"), ("DOT12-RPTR-MIB", "vgRptrPortSupportedCascadeMode"), ("DOT12-RPTR-MIB", "vgRptrInfoMACAddress"), ("DOT12-RPTR-MIB", "vgRptrGroupObjectID"), ("DOT12-RPTR-MIB", "vgRptrPortSupportedPromiscMode"), ("DOT12-RPTR-MIB", "vgRptrPortPriorityEnable"), ) )
if mibBuilder.loadTexts: vgRptrConfigGroup.setDescription("A collection of objects for managing the status\nand configuration of IEEE 802.12 repeaters.")
vgRptrStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 2)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrPortNormPriorityOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHighPriorityOctets"), ("DOT12-RPTR-MIB", "vgRptrPortUnreadOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortTransitionToTrainings"), ("DOT12-RPTR-MIB", "vgRptrMonReadableOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHighPriorityFrames"), ("DOT12-RPTR-MIB", "vgRptrPortOversizeFrames"), ("DOT12-RPTR-MIB", "vgRptrPortMulticastFrames"), ("DOT12-RPTR-MIB", "vgRptrPortBroadcastFrames"), ("DOT12-RPTR-MIB", "vgRptrPortNullAddressedFrames"), ("DOT12-RPTR-MIB", "vgRptrMonTotalReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortReadableFrames"), ("DOT12-RPTR-MIB", "vgRptrPortNormPriOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortHighPriOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortLastChange"), ("DOT12-RPTR-MIB", "vgRptrMonTotalReadableFrames"), ("DOT12-RPTR-MIB", "vgRptrPortNormPriorityFrames"), ("DOT12-RPTR-MIB", "vgRptrPortReadOctetRollovers"), ("DOT12-RPTR-MIB", "vgRptrPortPriorityPromotions"), ("DOT12-RPTR-MIB", "vgRptrMonTotalErrors"), ("DOT12-RPTR-MIB", "vgRptrPortIPMFrames"), ("DOT12-RPTR-MIB", "vgRptrPortDataErrorFrames"), ("DOT12-RPTR-MIB", "vgRptrPortUnreadableOctets"), ) )
if mibBuilder.loadTexts: vgRptrStatsGroup.setDescription("A collection of objects for providing statistics\nfor IEEE 802.12 repeaters.  Systems which support\nCounter64 should also implement\nvgRptrStats64Group.")
vgRptrStats64Group = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 3)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrPortHCReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrMonHCTotalReadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCNormPriorityOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCUnreadableOctets"), ("DOT12-RPTR-MIB", "vgRptrPortHCHighPriorityOctets"), ) )
if mibBuilder.loadTexts: vgRptrStats64Group.setDescription("A collection of objects for providing statistics\nfor IEEE 802.12 repeaters in a system that\nsupports Counter64.")
vgRptrAddrGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 4)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrRptrDetectedDupAddress"), ("DOT12-RPTR-MIB", "vgRptrAddrLastTrainedAddress"), ("DOT12-RPTR-MIB", "vgRptrMgrDetectedDupAddress"), ("DOT12-RPTR-MIB", "vgRptrAddrTrainedAddrChanges"), ) )
if mibBuilder.loadTexts: vgRptrAddrGroup.setDescription("A collection of objects for tracking addresses\non IEEE 802.12 repeaters.")
vgRptrNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 53, 3, 2, 5)).setObjects(*(("DOT12-RPTR-MIB", "vgRptrResetEvent"), ("DOT12-RPTR-MIB", "vgRptrHealth"), ) )
if mibBuilder.loadTexts: vgRptrNotificationsGroup.setDescription("A collection of notifications used to indicate\n802.12 repeater general status changes.")

# Compliances

vgRptrCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 53, 3, 1, 1)).setObjects(*(("SNMP-REPEATER-MIB", "snmpRptrGrpRptrAddrSearch"), ("DOT12-RPTR-MIB", "vgRptrNotificationsGroup"), ("DOT12-RPTR-MIB", "vgRptrConfigGroup"), ("DOT12-RPTR-MIB", "vgRptrAddrGroup"), ("DOT12-RPTR-MIB", "vgRptrStatsGroup"), ("DOT12-RPTR-MIB", "vgRptrStats64Group"), ) )
if mibBuilder.loadTexts: vgRptrCompliance.setDescription("The compliance statement for managed 802.12\nrepeaters.")

# Exports

# Module identity
mibBuilder.exportSymbols("DOT12-RPTR-MIB", PYSNMP_MODULE_ID=vgRptrMIB)

# Objects
mibBuilder.exportSymbols("DOT12-RPTR-MIB", vgRptrMIB=vgRptrMIB, vgRptrObjects=vgRptrObjects, vgRptrBasic=vgRptrBasic, vgRptrBasicRptr=vgRptrBasicRptr, vgRptrInfoTable=vgRptrInfoTable, vgRptrInfoEntry=vgRptrInfoEntry, vgRptrInfoIndex=vgRptrInfoIndex, vgRptrInfoMACAddress=vgRptrInfoMACAddress, vgRptrInfoCurrentFramingType=vgRptrInfoCurrentFramingType, vgRptrInfoDesiredFramingType=vgRptrInfoDesiredFramingType, vgRptrInfoFramingCapability=vgRptrInfoFramingCapability, vgRptrInfoTrainingVersion=vgRptrInfoTrainingVersion, vgRptrInfoOperStatus=vgRptrInfoOperStatus, vgRptrInfoReset=vgRptrInfoReset, vgRptrInfoLastChange=vgRptrInfoLastChange, vgRptrBasicGroup=vgRptrBasicGroup, vgRptrBasicGroupTable=vgRptrBasicGroupTable, vgRptrBasicGroupEntry=vgRptrBasicGroupEntry, vgRptrGroupIndex=vgRptrGroupIndex, vgRptrGroupObjectID=vgRptrGroupObjectID, vgRptrGroupOperStatus=vgRptrGroupOperStatus, vgRptrGroupPortCapacity=vgRptrGroupPortCapacity, vgRptrGroupCablesBundled=vgRptrGroupCablesBundled, vgRptrBasicPort=vgRptrBasicPort, vgRptrBasicPortTable=vgRptrBasicPortTable, vgRptrBasicPortEntry=vgRptrBasicPortEntry, vgRptrPortIndex=vgRptrPortIndex, vgRptrPortType=vgRptrPortType, vgRptrPortAdminStatus=vgRptrPortAdminStatus, vgRptrPortOperStatus=vgRptrPortOperStatus, vgRptrPortSupportedPromiscMode=vgRptrPortSupportedPromiscMode, vgRptrPortSupportedCascadeMode=vgRptrPortSupportedCascadeMode, vgRptrPortAllowedTrainType=vgRptrPortAllowedTrainType, vgRptrPortLastTrainConfig=vgRptrPortLastTrainConfig, vgRptrPortTrainingResult=vgRptrPortTrainingResult, vgRptrPortPriorityEnable=vgRptrPortPriorityEnable, vgRptrPortRptrInfoIndex=vgRptrPortRptrInfoIndex, vgRptrMonitor=vgRptrMonitor, vgRptrMonRepeater=vgRptrMonRepeater, vgRptrMonitorTable=vgRptrMonitorTable, vgRptrMonitorEntry=vgRptrMonitorEntry, vgRptrMonTotalReadableFrames=vgRptrMonTotalReadableFrames, vgRptrMonTotalReadableOctets=vgRptrMonTotalReadableOctets, vgRptrMonReadableOctetRollovers=vgRptrMonReadableOctetRollovers, vgRptrMonHCTotalReadableOctets=vgRptrMonHCTotalReadableOctets, vgRptrMonTotalErrors=vgRptrMonTotalErrors, vgRptrMonGroup=vgRptrMonGroup, vgRptrMonPort=vgRptrMonPort, vgRptrMonPortTable=vgRptrMonPortTable, vgRptrMonPortEntry=vgRptrMonPortEntry, vgRptrPortReadableFrames=vgRptrPortReadableFrames, vgRptrPortReadableOctets=vgRptrPortReadableOctets, vgRptrPortReadOctetRollovers=vgRptrPortReadOctetRollovers, vgRptrPortHCReadableOctets=vgRptrPortHCReadableOctets, vgRptrPortUnreadableOctets=vgRptrPortUnreadableOctets, vgRptrPortUnreadOctetRollovers=vgRptrPortUnreadOctetRollovers, vgRptrPortHCUnreadableOctets=vgRptrPortHCUnreadableOctets, vgRptrPortHighPriorityFrames=vgRptrPortHighPriorityFrames, vgRptrPortHighPriorityOctets=vgRptrPortHighPriorityOctets, vgRptrPortHighPriOctetRollovers=vgRptrPortHighPriOctetRollovers, vgRptrPortHCHighPriorityOctets=vgRptrPortHCHighPriorityOctets, vgRptrPortNormPriorityFrames=vgRptrPortNormPriorityFrames, vgRptrPortNormPriorityOctets=vgRptrPortNormPriorityOctets, vgRptrPortNormPriOctetRollovers=vgRptrPortNormPriOctetRollovers, vgRptrPortHCNormPriorityOctets=vgRptrPortHCNormPriorityOctets, vgRptrPortBroadcastFrames=vgRptrPortBroadcastFrames, vgRptrPortMulticastFrames=vgRptrPortMulticastFrames, vgRptrPortNullAddressedFrames=vgRptrPortNullAddressedFrames, vgRptrPortIPMFrames=vgRptrPortIPMFrames, vgRptrPortOversizeFrames=vgRptrPortOversizeFrames, vgRptrPortDataErrorFrames=vgRptrPortDataErrorFrames, vgRptrPortPriorityPromotions=vgRptrPortPriorityPromotions, vgRptrPortTransitionToTrainings=vgRptrPortTransitionToTrainings, vgRptrPortLastChange=vgRptrPortLastChange, vgRptrAddrTrack=vgRptrAddrTrack, vgRptrAddrTrackRptr=vgRptrAddrTrackRptr, vgRptrAddrTrackGroup=vgRptrAddrTrackGroup, vgRptrAddrTrackPort=vgRptrAddrTrackPort, vgRptrAddrTrackTable=vgRptrAddrTrackTable, vgRptrAddrTrackEntry=vgRptrAddrTrackEntry, vgRptrAddrLastTrainedAddress=vgRptrAddrLastTrainedAddress, vgRptrAddrTrainedAddrChanges=vgRptrAddrTrainedAddrChanges, vgRptrRptrDetectedDupAddress=vgRptrRptrDetectedDupAddress, vgRptrMgrDetectedDupAddress=vgRptrMgrDetectedDupAddress, vgRptrTraps=vgRptrTraps, vgRptrTrapPrefix=vgRptrTrapPrefix, vgRptrConformance=vgRptrConformance, vgRptrCompliances=vgRptrCompliances, vgRptrGroups=vgRptrGroups)

# Notifications
mibBuilder.exportSymbols("DOT12-RPTR-MIB", vgRptrHealth=vgRptrHealth, vgRptrResetEvent=vgRptrResetEvent)

# Groups
mibBuilder.exportSymbols("DOT12-RPTR-MIB", vgRptrConfigGroup=vgRptrConfigGroup, vgRptrStatsGroup=vgRptrStatsGroup, vgRptrStats64Group=vgRptrStats64Group, vgRptrAddrGroup=vgRptrAddrGroup, vgRptrNotificationsGroup=vgRptrNotificationsGroup)

# Compliances
mibBuilder.exportSymbols("DOT12-RPTR-MIB", vgRptrCompliance=vgRptrCompliance)
