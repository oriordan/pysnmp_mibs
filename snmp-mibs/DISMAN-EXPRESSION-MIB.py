# PySNMP SMI module. Autogenerated from smidump -f python DISMAN-EXPRESSION-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:35 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( sysUpTime, ) = mibBuilder.importSymbols("SNMPv2-MIB", "sysUpTime")
( Bits, Counter32, Counter64, Gauge32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, TimeTicks, Unsigned32, mib_2, zeroDotZero, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Counter64", "Gauge32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "TimeTicks", "Unsigned32", "mib-2", "zeroDotZero")
( RowStatus, TimeStamp, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TimeStamp", "TruthValue")

# Objects

sysUpTimeInstance = MibIdentifier((1, 3, 6, 1, 2, 1, 1, 3, 0))
dismanExpressionMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 90)).setRevisions(("2000-10-16 00:00",))
if mibBuilder.loadTexts: dismanExpressionMIB.setOrganization("IETF Distributed Management Working Group")
if mibBuilder.loadTexts: dismanExpressionMIB.setContactInfo("Ramanathan Kavasseri\nCisco Systems, Inc.\n170 West Tasman Drive,\nSan Jose CA 95134-1706.\nPhone: +1 408 527 2446\nEmail: ramk@cisco.com")
if mibBuilder.loadTexts: dismanExpressionMIB.setDescription("The MIB module for defining expressions of MIB objects for\nmanagement purposes.")
dismanExpressionMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 1))
expResource = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 1, 1))
expResourceDeltaMinimum = MibScalar((1, 3, 6, 1, 2, 1, 90, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1,-1),ValueRangeConstraint(1,600),))).setMaxAccess("readwrite").setUnits("seconds")
if mibBuilder.loadTexts: expResourceDeltaMinimum.setDescription("The minimum expExpressionDeltaInterval this system will\naccept.  A system may use the larger values of this minimum to\nlessen the impact of constantly computing deltas.  For larger\ndelta sampling intervals the system samples less often and\nsuffers less overhead.  This object provides a way to enforce\nsuch lower overhead for all expressions created after it is\nset.\n\nThe value -1 indicates that expResourceDeltaMinimum is\nirrelevant as the system will not accept 'deltaValue' as a\nvalue for expObjectSampleType.\n\nUnless explicitly resource limited, a system's value for\nthis object should be 1, allowing as small as a 1 second\ninterval for ongoing delta sampling.\n\nChanging this value will not invalidate an existing setting\nof expObjectSampleType.")
expResourceDeltaWildcardInstanceMaximum = MibScalar((1, 3, 6, 1, 2, 1, 90, 1, 1, 2), Unsigned32()).setMaxAccess("readwrite").setUnits("instances")
if mibBuilder.loadTexts: expResourceDeltaWildcardInstanceMaximum.setDescription("For every instance of a deltaValue object, one dynamic instance\nentry is needed for holding the instance value from the previous\nsample, i.e. to maintain state.\n\nThis object limits maximum number of dynamic instance entries\nthis system will support for wildcarded delta objects in\nexpressions. For a given delta expression, the number of\ndynamic instances is the number of values that meet all criteria\nto exist times the number of delta values in the expression.\n\nA value of 0 indicates no preset limit, that is, the limit\nis dynamic based on system operation and resources.\n\nUnless explicitly resource limited, a system's value for\nthis object should be 0.\n\n\n\nChanging this value will not eliminate or inhibit existing delta\nwildcard instance objects but will prevent the creation of more\nsuch objects.\n\nAn attempt to allocate beyond the limit results in expErrorCode\nbeing tooManyWildcardValues for that evaluation attempt.")
expResourceDeltaWildcardInstances = MibScalar((1, 3, 6, 1, 2, 1, 90, 1, 1, 3), Gauge32()).setMaxAccess("readonly").setUnits("instances")
if mibBuilder.loadTexts: expResourceDeltaWildcardInstances.setDescription("The number of currently active instance entries as\ndefined for expResourceDeltaWildcardInstanceMaximum.")
expResourceDeltaWildcardInstancesHigh = MibScalar((1, 3, 6, 1, 2, 1, 90, 1, 1, 4), Gauge32()).setMaxAccess("readonly").setUnits("instances")
if mibBuilder.loadTexts: expResourceDeltaWildcardInstancesHigh.setDescription("The highest value of expResourceDeltaWildcardInstances\nthat has occurred since initialization of the managed\nsystem.")
expResourceDeltaWildcardInstanceResourceLacks = MibScalar((1, 3, 6, 1, 2, 1, 90, 1, 1, 5), Counter32()).setMaxAccess("readonly").setUnits("instances")
if mibBuilder.loadTexts: expResourceDeltaWildcardInstanceResourceLacks.setDescription("The number of times this system could not evaluate an\nexpression because that would have created a value instance in\nexcess of expResourceDeltaWildcardInstanceMaximum.")
expDefine = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 1, 2))
expExpressionTable = MibTable((1, 3, 6, 1, 2, 1, 90, 1, 2, 1))
if mibBuilder.loadTexts: expExpressionTable.setDescription("A table of expression definitions.")
expExpressionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1)).setIndexNames((0, "DISMAN-EXPRESSION-MIB", "expExpressionOwner"), (0, "DISMAN-EXPRESSION-MIB", "expExpressionName"))
if mibBuilder.loadTexts: expExpressionEntry.setDescription("Information about a single expression.  New expressions\ncan be created using expExpressionRowStatus.\n\nTo create an expression first create the named entry in this\ntable.  Then use expExpressionName to populate expObjectTable.\nFor expression evaluation to succeed all related entries in\nexpExpressionTable and expObjectTable must be 'active'.  If\nthese conditions are not met the corresponding values in\nexpValue simply are not instantiated.\n\nDeleting an entry deletes all related entries in expObjectTable\nand expErrorTable.\n\nBecause of the relationships among the multiple tables for an\nexpression (expExpressionTable, expObjectTable, and\nexpValueTable) and the SNMP rules for independence in setting\nobject values, it is necessary to do final error checking when\nan expression is evaluated, that is, when one of its instances\nin expValueTable is read or a delta interval expires.  Earlier\nchecking need not be done and an implementation may not impose\nany ordering on the creation of objects related to an\nexpression.\n\nTo maintain security of MIB information, when creating a new row in\nthis table, the managed system must record the security credentials\nof the requester.  These security credentials are the parameters\nnecessary as inputs to isAccessAllowed from the Architecture for\n\nDescribing SNMP Management Frameworks.  When obtaining the objects\nthat make up the expression, the system must (conceptually) use\nisAccessAllowed to ensure that it does not violate security.\n\nThe evaluation of the expression takes place under the\nsecurity credentials of the creator of its expExpressionEntry.\n\nValues of read-write objects in this table may be changed\n\n\nat any time.")
expExpressionOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: expExpressionOwner.setDescription("The owner of this entry. The exact semantics of this\nstring are subject to the security policy defined by the\nsecurity administrator.")
expExpressionName = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: expExpressionName.setDescription("The name of the expression.  This is locally unique, within\nthe scope of an expExpressionOwner.")
expExpression = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expExpression.setDescription("The expression to be evaluated.  This object is the same\nas a DisplayString (RFC 1903) except for its maximum length.\n\nExcept for the variable names the expression is in ANSI C\nsyntax.  Only the subset of ANSI C operators and functions\nlisted here is allowed.\n\nVariables are expressed as a dollar sign ('$') and an\n\n\ninteger that corresponds to an expObjectIndex.  An\nexample of a valid expression is:\n\n     ($1-$5)*100\n\nExpressions must not be recursive, that is although an expression\nmay use the results of another expression, it must not contain\nany variable that is directly or indirectly a result of its own\nevaluation. The managed system must check for recursive\nexpressions.\n\nThe only allowed operators are:\n\n     ( )\n     - (unary)\n     + - * / %\n     & | ^ << >> ~\n     ! && || == != > >= < <=\n\nNote the parentheses are included for parenthesizing the\nexpression, not for casting data types.\n\nThe only constant types defined are:\n\n     int (32-bit signed)\n     long (64-bit signed)\n     unsigned int\n     unsigned long\n     hexadecimal\n     character\n     string\n     oid\n\nThe default type for a positive integer is int unless it is too\nlarge in which case it is long.\n\nAll but oid are as defined for ANSI C.  Note that a\nhexadecimal constant may end up as a scalar or an array of\n8-bit integers.  A string constant is enclosed in double\nquotes and may contain back-slashed individual characters\nas in ANSI C.\n\nAn oid constant comprises 32-bit, unsigned integers and at\nleast one period, for example:\n\n     0.\n     .0\n     1.3.6.1\n\n\nNo additional leading or trailing subidentifiers are automatically\nadded to an OID constant.  The constant is taken as expressed.\n\nInteger-typed objects are treated as 32- or 64-bit, signed\nor unsigned integers, as appropriate.  The results of\nmixing them are as for ANSI C, including the type of the\nresult.  Note that a 32-bit value is thus promoted to 64 bits\nonly in an operation with a 64-bit value.  There is no\nprovision for larger values to handle overflow.\n\nRelative to SNMP data types, a resulting value becomes\nunsigned when calculating it uses any unsigned value,\nincluding a counter.  To force the final value to be of\ndata type counter the expression must explicitly use the\ncounter32() or counter64() function (defined below).\n\nOCTET STRINGS and OBJECT IDENTIFIERs are treated as\none-dimensioned arrays of unsigned 8-bit integers and\nunsigned 32-bit integers, respectively.\n\nIpAddresses are treated as 32-bit, unsigned integers in\nnetwork byte order, that is, the hex version of 255.0.0.0 is\n0xff000000.\n\nConditional expressions result in a 32-bit, unsigned integer\nof value 0 for false or 1 for true. When an arbitrary value\nis used as a boolean 0 is false and non-zero is true.\n\nRules for the resulting data type from an operation, based on\nthe operator:\n\nFor << and >> the result is the same as the left hand operand.\n\nFor &&, ||, ==, !=, <, <=, >, and >= the result is always\nUnsigned32.\n\nFor unary - the result is always Integer32.\n\nFor +, -, *, /, %, &, |, and ^ the result is promoted according\nto the following rules, in order from most to least preferred:\n\n     If left hand and right hand operands are the same type,\n     use that.\n\n     If either side is Counter64, use that.\n\n     If either side is IpAddress, use that.\n\n\n\n     If either side is TimeTicks, use that.\n\n     If either side is Counter32, use that.\n\n     Otherwise use Unsigned32.\n\nThe following rules say what operators apply with what data\ntypes.  Any combination not explicitly defined does not work.\n\nFor all operators any of the following can be the left hand or\nright hand operand: Integer32, Counter32, Unsigned32, Counter64.\n\nThe operators +, -, *, /, %, <, <=, >, and >= work with\nTimeTicks.\n\nThe operators &, |, and ^ work with IpAddress.\n\nThe operators << and >> work with IpAddress but only as the\nleft hand operand.\n\nThe + operator performs a concatenation of two OCTET STRINGs or\ntwo OBJECT IDENTIFIERs.\n\nThe operators &, | perform bitwise operations on OCTET STRINGs.\nIf the OCTET STRING happens to be a DisplayString the results\nmay be meaningless, but the agent system does not check this as\nsome such systems do not have this information.\n\nThe operators << and >> perform bitwise operations on OCTET\nSTRINGs appearing as the left hand operand.\n\nThe only functions defined are:\n\n     counter32\n     counter64\n     arraySection\n     stringBegins\n     stringEnds\n     stringContains\n     oidBegins\n     oidEnds\n     oidContains\n     average\n     maximum\n     minimum\n     sum\n     exists\n\n\n\nThe following function definitions indicate their parameters by\nnaming the data type of the parameter in the parameter's position\nin the parameter list.  The parameter must be of the type indicated\nand generally may be a constant, a MIB object, a function, or an\nexpression.\n\ncounter32(integer) - wrapped around an integer value counter32\nforces Counter32 as a data type.\n\ncounter64(integer) - similar to counter32 except that the\nresulting data type is 'counter64'.\n\narraySection(array, integer, integer) - selects a piece of an\narray (i.e. part of an OCTET STRING or OBJECT IDENTIFIER).  The\ninteger arguments are in the range 0 to 4,294,967,295.  The\nfirst is an initial array index (one-dimensioned) and the second\nis an ending array index.  A value of 0 indicates first or last\nelement, respectively.  If the first element is larger than the\narray length the result is 0 length.  If the second integer is\nless than or equal to the first, the result is 0 length.  If the\nsecond is larger than the array length it indicates last\nelement.\n\nstringBegins/Ends/Contains(octetString, octetString) - looks for\nthe second string (which can be a string constant) in the first\nand returns the one-dimensioned arrayindex where the match began.\nA return value of 0 indicates no match (i.e. boolean false).\n\noidBegins/Ends/Contains(oid, oid) - looks for the second OID\n(which can be an OID constant) in the first and returns the\nthe one-dimensioned index where the match began. A return value\nof 0 indicates no match (i.e. boolean false).\n\naverage/maximum/minimum(integer) - calculates the average,\nminimum, or maximum value of the integer valued object over\nmultiple sample times.  If the object disappears for any\nsample period, the accumulation and the resulting value object\ncease to exist until the object reappears at which point the\ncalculation starts over.\n\nsum(integerObject*) - sums all available values of the\nwildcarded integer object, resulting in an integer scalar.  Must\nbe used with caution as it wraps on overflow with no\nnotification.\n\nexists(anyTypeObject) - verifies the object instance exists. A\nreturn value of 0 indicates NoSuchInstance (i.e. boolean\nfalse).")
expExpressionValueType = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(4,6,7,5,3,8,2,1,)).subtype(namedValues=NamedValues(("counter32", 1), ("unsigned32", 2), ("timeTicks", 3), ("integer32", 4), ("ipAddress", 5), ("octetString", 6), ("objectId", 7), ("counter64", 8), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expExpressionValueType.setDescription("The type of the expression value.  One and only one of the\nvalue objects in expValueTable will be instantiated to match\nthis type.\n\nIf the result of the expression can not be made into this type,\nan invalidOperandType error will occur.")
expExpressionComment = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 5), SnmpAdminString().clone('')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expExpressionComment.setDescription("A comment to explain the use or meaning of the expression.")
expExpressionDeltaInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 86400)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expExpressionDeltaInterval.setDescription("Sampling interval for objects in this expression with\nexpObjectSampleType 'deltaValue'.\n\nThis object has no effect if the the expression has no\ndeltaValue objects.\n\nA value of 0 indicates no automated sampling.  In this case\nthe delta is the difference from the last time the expression\nwas evaluated.  Note that this is subject to unpredictable\ndelta times in the face of retries or multiple managers.\n\nA value greater than zero is the number of seconds between\nautomated samples.\n\nUntil the delta interval has expired once the delta for the\n\n\nobject is effectively not instantiated and evaluating\nthe expression has results as if the object itself were not\ninstantiated.\n\nNote that delta values potentially consume large amounts of\nsystem CPU and memory.  Delta state and processing must\ncontinue constantly even if the expression is not being used.\nThat is, the expression is being evaluated every delta interval,\neven if no application is reading those values.  For wildcarded\nobjects this can be substantial overhead.\n\nNote that delta intervals, external expression value sampling\nintervals and delta intervals for expressions within other\nexpressions can have unusual interactions as they are impossible\nto synchronize accurately.  In general one interval embedded\nbelow another must be enough shorter that the higher sample\nsees relatively smooth, predictable behavior.  So, for example,\nto avoid the higher level getting the same sample twice, the\nlower level should sample at least twice as fast as the higher\nlevel does.")
expExpressionPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 7), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expExpressionPrefix.setDescription("An object prefix to assist an application in determining\nthe instance indexing to use in expValueTable, relieving the\napplication of the need to scan the expObjectTable to\ndetermine such a prefix.\n\nSee expObjectTable for information on wildcarded objects.\n\nIf the expValueInstance portion of the value OID may\nbe treated as a scalar (that is, normally, 0) the value of\nexpExpressionPrefix is zero length, that is, no OID at all.\nNote that zero length implies a null OID, not the OID 0.0.\n\nOtherwise, the value of expExpressionPrefix is the expObjectID\nvalue of any one of the wildcarded objects for the expression.\nThis is sufficient, as the remainder, that is, the instance\nfragment relevant to instancing the values, must be the same for\nall wildcarded objects in the expression.")
expExpressionErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expExpressionErrors.setDescription("The number of errors encountered while evaluating this\nexpression.\n\nNote that an object in the expression not being accessible,\nis not considered an error. An example of an inaccessible\nobject is when the object is excluded from the view of the\nuser whose security credentials are used in the expression\nevaluation. In such cases, it is a legitimate condition\nthat causes the corresponding expression value not to be\ninstantiated.")
expExpressionEntryStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expExpressionEntryStatus.setDescription("The control that allows creation and deletion of entries.")
expErrorTable = MibTable((1, 3, 6, 1, 2, 1, 90, 1, 2, 2))
if mibBuilder.loadTexts: expErrorTable.setDescription("A table of expression errors.")
expErrorEntry = MibTableRow((1, 3, 6, 1, 2, 1, 90, 1, 2, 2, 1)).setIndexNames((0, "DISMAN-EXPRESSION-MIB", "expExpressionOwner"), (0, "DISMAN-EXPRESSION-MIB", "expExpressionName"))
if mibBuilder.loadTexts: expErrorEntry.setDescription("Information about errors in processing an expression.\n\nEntries appear in this table only when there is a matching\nexpExpressionEntry and then only when there has been an\nerror for that expression as reflected by the error codes\ndefined for expErrorCode.")
expErrorTime = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 2, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expErrorTime.setDescription("The value of sysUpTime the last time an error caused a\nfailure to evaluate this expression.")
expErrorIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expErrorIndex.setDescription("The one-dimensioned character array index into\nexpExpression for where the error occurred.  The value\nzero indicates irrelevance.")
expErrorCode = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 2, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(11,3,6,9,10,1,2,8,7,5,4,)).subtype(namedValues=NamedValues(("invalidSyntax", 1), ("resourceUnavailable", 10), ("divideByZero", 11), ("undefinedObjectIndex", 2), ("unrecognizedOperator", 3), ("unrecognizedFunction", 4), ("invalidOperandType", 5), ("unmatchedParenthesis", 6), ("tooManyWildcardValues", 7), ("recursion", 8), ("deltaTooShort", 9), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: expErrorCode.setDescription("The error that occurred.  In the following explanations the\nexpected timing of the error is in parentheses.  'S' means\nthe error occurs on a Set request.  'E' means the error\n\n\noccurs on the attempt to evaluate the expression either due to\nGet from expValueTable or in ongoing delta processing.\n\ninvalidSyntax       the value sent for expExpression is not\n               valid Expression MIB expression syntax\n               (S)\nundefinedObjectIndex     an object reference ($n) in\n               expExpression does not have a matching\n               instance in expObjectTable (E)\nunrecognizedOperator     the value sent for expExpression held an\n               unrecognized operator (S)\nunrecognizedFunction     the value sent for expExpression held an\n               unrecognized function name (S)\ninvalidOperandType  an operand in expExpression is not the\n               right type for the associated operator\n               or result (SE)\nunmatchedParenthesis     the value sent for expExpression is not\n               correctly parenthesized (S)\ntooManyWildcardValues    evaluating the expression exceeded the\n               limit set by\n               expResourceDeltaWildcardInstanceMaximum\n               (E)\nrecursion      through some chain of embedded\n               expressions the expression invokes itself\n               (E)\ndeltaTooShort       the delta for the next evaluation passed\n               before the system could evaluate the\n               present sample (E)\nresourceUnavailable some resource, typically dynamic memory,\n               was unavailable (SE)\ndivideByZero        an attempt to divide by zero occurred\n               (E)\n\nFor the errors that occur when the attempt is made to set\nexpExpression Set request fails with the SNMP error code\n'wrongValue'.  Such failures refer to the most recent failure to\nSet expExpression, not to the present value of expExpression\nwhich must be either unset or syntactically correct.\n\nErrors that occur during evaluation for a Get* operation return\nthe SNMP error code 'genErr' except for 'tooManyWildcardValues'\nand 'resourceUnavailable' which return the SNMP error code\n'resourceUnavailable'.")
expErrorInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expErrorInstance.setDescription("The expValueInstance being evaluated when the error\noccurred.  A zero-length indicates irrelevance.")
expObjectTable = MibTable((1, 3, 6, 1, 2, 1, 90, 1, 2, 3))
if mibBuilder.loadTexts: expObjectTable.setDescription("A table of object definitions for each expExpression.\n\nWildcarding instance IDs:\n\nIt is legal to omit all or part of the instance portion for\nsome or all of the objects in an expression. (See the\nDESCRIPTION of expObjectID for details.  However, note that\nif more than one object in the same expression is wildcarded\nin this way, they all must be objects where that portion of\nthe instance is the same.  In other words, all objects may be\nin the same SEQUENCE or in different SEQUENCEs but with the\nsame semantic index value (e.g., a value of ifIndex)\nfor the wildcarded portion.")
expObjectEntry = MibTableRow((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1)).setIndexNames((0, "DISMAN-EXPRESSION-MIB", "expExpressionOwner"), (0, "DISMAN-EXPRESSION-MIB", "expExpressionName"), (0, "DISMAN-EXPRESSION-MIB", "expObjectIndex"))
if mibBuilder.loadTexts: expObjectEntry.setDescription("Information about an object.  An application uses\nexpObjectEntryStatus to create entries in this table while\nin the process of defining an expression.\n\nValues of read-create objects in this table may be\nchanged at any time.")
expObjectIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: expObjectIndex.setDescription("Within an expression, a unique, numeric identification for an\nobject.  Prefixed with a dollar sign ('$') this is used to\nreference the object in the corresponding expExpression.")
expObjectID = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 2), ObjectIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectID.setDescription("The OBJECT IDENTIFIER (OID) of this object.  The OID may be\nfully qualified, meaning it includes a complete instance\nidentifier part (e.g., ifInOctets.1 or sysUpTime.0), or it\nmay not be fully qualified, meaning it may lack all or part\nof the instance identifier.  If the expObjectID is not fully\nqualified, then expObjectWildcard must be set to true(1).\nThe value of the expression will be multiple\nvalues, as if done for a GetNext sweep of the object.\n\nAn object here may itself be the result of an expression but\nrecursion is not allowed.\n\nNOTE:  The simplest implementations of this MIB may not allow\nwildcards.")
expObjectIDWildcard = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectIDWildcard.setDescription("A true value indicates the expObjecID of this row is a wildcard\nobject. False indicates that expObjectID is fully instanced.\nIf all expObjectWildcard values for a given expression are FALSE,\n\n\nexpExpressionPrefix will reflect a scalar object (i.e. will\nbe 0.0).\n\nNOTE:  The simplest implementations of this MIB may not allow\nwildcards.")
expObjectSampleType = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(3,1,2,)).subtype(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2), ("changedValue", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectSampleType.setDescription("The method of sampling the selected variable.\n\nAn 'absoluteValue' is simply the present value of the object.\n\nA 'deltaValue' is the present value minus the previous value,\nwhich was sampled expExpressionDeltaInterval seconds ago.\nThis is intended primarily for use with SNMP counters, which are\nmeaningless as an 'absoluteValue', but may be used with any\ninteger-based value.\n\nA 'changedValue' is a boolean for whether the present value is\ndifferent from the previous value.  It is applicable to any data\ntype and results in an Unsigned32 with value 1 if the object's\nvalue is changed and 0 if not.  In all other respects it is as a\n'deltaValue' and all statements and operation regarding delta\nvalues apply to changed values.\n\nWhen an expression contains both delta and absolute values\nthe absolute values are obtained at the end of the delta\nperiod.")
expObjectDeltaDiscontinuityID = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 5), ObjectIdentifier().clone((1, 3, 6, 1, 2, 1, 1, 3, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectDeltaDiscontinuityID.setDescription("The OBJECT IDENTIFIER (OID) of a TimeTicks, TimeStamp, or\nDateAndTime object that indicates a discontinuity in the value\nat expObjectID.\n\n\n\nThis object is instantiated only if expObjectSampleType is\n'deltaValue' or 'changedValue'.\n\nThe OID may be for a leaf object (e.g. sysUpTime.0) or may\nbe wildcarded to match expObjectID.\n\nThis object supports normal checking for a discontinuity in a\ncounter.  Note that if this object does not point to sysUpTime\ndiscontinuity checking must still check sysUpTime for an overall\ndiscontinuity.\n\nIf the object identified is not accessible no discontinuity\ncheck will be made.")
expObjectDiscontinuityIDWildcard = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectDiscontinuityIDWildcard.setDescription("A true value indicates the expObjectDeltaDiscontinuityID of\nthis row is a wildcard object.  False indicates that\nexpObjectDeltaDiscontinuityID is fully instanced.\n\nThis object is instantiated only if expObjectSampleType is\n'deltaValue' or 'changedValue'.\n\nNOTE:  The simplest implementations of this MIB may not allow\nwildcards.")
expObjectDiscontinuityIDType = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("timeTicks", 1), ("timeStamp", 2), ("dateAndTime", 3), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectDiscontinuityIDType.setDescription("The value 'timeTicks' indicates the expObjectDeltaDiscontinuityID\nof this row is of syntax TimeTicks.  The value 'timeStamp' indicates\nsyntax TimeStamp.  The value 'dateAndTime indicates syntax\nDateAndTime.\n\nThis object is instantiated only if expObjectSampleType is\n'deltaValue' or 'changedValue'.")
expObjectConditional = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 8), ObjectIdentifier().clone((0, 0))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectConditional.setDescription("The OBJECT IDENTIFIER (OID) of an object that overrides\nwhether the instance of expObjectID is to be considered\nusable.  If the value of the object at expObjectConditional\nis 0 or not instantiated, the object at expObjectID is\ntreated as if it is not instantiated.  In other words,\nexpObjectConditional is a filter that controls whether or\nnot to use the value at expObjectID.\n\nThe OID may be for a leaf object (e.g. sysObjectID.0) or may be\nwildcarded to match expObjectID.  If expObject is wildcarded and\nexpObjectID in the same row is not, the wild portion of\nexpObjectConditional must match the wildcarding of the rest of\nthe expression.  If no object in the expression is wildcarded\nbut expObjectConditional is, use the lexically first instance\n(if any) of expObjectConditional.\n\nIf the value of expObjectConditional is 0.0 operation is\nas if the value pointed to by expObjectConditional is a\nnon-zero (true) value.\n\nNote that expObjectConditional can not trivially use an object\nof syntax TruthValue, since the underlying value is not 0 or 1.")
expObjectConditionalWildcard = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 9), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectConditionalWildcard.setDescription("A true value indicates the expObjectConditional of this row is\na wildcard object. False indicates that expObjectConditional is\nfully instanced.\n\nNOTE: The simplest implementations of this MIB may not allow\nwildcards.")
expObjectEntryStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 2, 3, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: expObjectEntryStatus.setDescription("The control that allows creation/deletion of entries.\n\nObjects in this table may be changed while\nexpObjectEntryStatus is in any state.")
expValue = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 1, 3))
expValueTable = MibTable((1, 3, 6, 1, 2, 1, 90, 1, 3, 1))
if mibBuilder.loadTexts: expValueTable.setDescription("A table of values from evaluated expressions.")
expValueEntry = MibTableRow((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1)).setIndexNames((0, "DISMAN-EXPRESSION-MIB", "expExpressionOwner"), (0, "DISMAN-EXPRESSION-MIB", "expExpressionName"), (1, "DISMAN-EXPRESSION-MIB", "expValueInstance"))
if mibBuilder.loadTexts: expValueEntry.setDescription("A single value from an evaluated expression.  For a given\ninstance, only one 'Val' object in the conceptual row will be\ninstantiated, that is, the one with the appropriate type for\nthe value.  For values that contain no objects of\nexpObjectSampleType 'deltaValue' or 'changedValue', reading a\nvalue from the table causes the evaluation of the expression\nfor that value.  For those that contain a 'deltaValue' or\n'changedValue' the value read is as of the last sampling\ninterval.\n\nIf in the attempt to evaluate the expression one or more\nof the necessary objects is not available, the corresponding\nentry in this table is effectively not instantiated.\n\nTo maintain security of MIB information, when creating a new\nrow in this table, the managed system must record the security\ncredentials of the requester.  These security credentials are\nthe parameters necessary as inputs to isAccessAllowed from\n[RFC2571]. When obtaining the objects that make up the\nexpression, the system must (conceptually) use isAccessAllowed to\nensure that it does not violate security.\n\nThe evaluation of that expression takes place under the\n\n\nsecurity credentials of the creator of its expExpressionEntry.\n\nTo maintain security of MIB information, expression evaluation must\ntake place using security credentials for the implied Gets of the\nobjects in the expression as inputs (conceptually) to\nisAccessAllowed from the Architecture for Describing SNMP\nManagement Frameworks.  These are the security credentials of the\ncreator of the corresponding expExpressionEntry.")
expValueInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 1), ObjectIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: expValueInstance.setDescription("The final instance portion of a value's OID according to\nthe wildcarding in instances of expObjectID for the\nexpression.  The prefix of this OID fragment is 0.0,\nleading to the following behavior.\n\nIf there is no wildcarding, the value is 0.0.0.  In other\nwords, there is one value which standing alone would have\nbeen a scalar with a 0 at the end of its OID.\n\nIf there is wildcarding, the value is 0.0 followed by\na value that the wildcard can take, thus defining one value\ninstance for each real, possible value of the wildcard.\nSo, for example, if the wildcard worked out to be an ifIndex,\nthere is an expValueInstance for each applicable ifIndex.")
expValueCounter32Val = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueCounter32Val.setDescription("The value when expExpressionValueType is 'counter32'.")
expValueUnsigned32Val = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueUnsigned32Val.setDescription("The value when expExpressionValueType is 'unsigned32'.")
expValueTimeTicksVal = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueTimeTicksVal.setDescription("The value when expExpressionValueType is 'timeTicks'.")
expValueInteger32Val = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueInteger32Val.setDescription("The value when expExpressionValueType is 'integer32'.")
expValueIpAddressVal = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueIpAddressVal.setDescription("The value when expExpressionValueType is 'ipAddress'.")
expValueOctetStringVal = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueOctetStringVal.setDescription("The value when expExpressionValueType is 'octetString'.")
expValueOidVal = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 8), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueOidVal.setDescription("The value when expExpressionValueType is 'objectId'.")
expValueCounter64Val = MibTableColumn((1, 3, 6, 1, 2, 1, 90, 1, 3, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: expValueCounter64Val.setDescription("The value when expExpressionValueType is 'counter64'.")
dismanExpressionMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 3))
dismanExpressionMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 3, 1))
dismanExpressionMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 90, 3, 2))

# Augmentions

# Groups

dismanExpressionResourceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 90, 3, 2, 1)).setObjects(*(("DISMAN-EXPRESSION-MIB", "expResourceDeltaMinimum"), ("DISMAN-EXPRESSION-MIB", "expResourceDeltaWildcardInstancesHigh"), ("DISMAN-EXPRESSION-MIB", "expResourceDeltaWildcardInstances"), ("DISMAN-EXPRESSION-MIB", "expResourceDeltaWildcardInstanceResourceLacks"), ("DISMAN-EXPRESSION-MIB", "expResourceDeltaWildcardInstanceMaximum"), ) )
if mibBuilder.loadTexts: dismanExpressionResourceGroup.setDescription("Expression definition resource management.")
dismanExpressionDefinitionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 90, 3, 2, 2)).setObjects(*(("DISMAN-EXPRESSION-MIB", "expObjectID"), ("DISMAN-EXPRESSION-MIB", "expObjectConditional"), ("DISMAN-EXPRESSION-MIB", "expExpressionComment"), ("DISMAN-EXPRESSION-MIB", "expObjectDiscontinuityIDWildcard"), ("DISMAN-EXPRESSION-MIB", "expErrorInstance"), ("DISMAN-EXPRESSION-MIB", "expExpressionErrors"), ("DISMAN-EXPRESSION-MIB", "expExpression"), ("DISMAN-EXPRESSION-MIB", "expErrorTime"), ("DISMAN-EXPRESSION-MIB", "expErrorIndex"), ("DISMAN-EXPRESSION-MIB", "expExpressionEntryStatus"), ("DISMAN-EXPRESSION-MIB", "expExpressionValueType"), ("DISMAN-EXPRESSION-MIB", "expObjectEntryStatus"), ("DISMAN-EXPRESSION-MIB", "expObjectDeltaDiscontinuityID"), ("DISMAN-EXPRESSION-MIB", "expObjectSampleType"), ("DISMAN-EXPRESSION-MIB", "expExpressionDeltaInterval"), ("DISMAN-EXPRESSION-MIB", "expExpressionPrefix"), ("DISMAN-EXPRESSION-MIB", "expObjectDiscontinuityIDType"), ("DISMAN-EXPRESSION-MIB", "expObjectConditionalWildcard"), ("DISMAN-EXPRESSION-MIB", "expObjectIDWildcard"), ("DISMAN-EXPRESSION-MIB", "expErrorCode"), ) )
if mibBuilder.loadTexts: dismanExpressionDefinitionGroup.setDescription("Expression definition.")
dismanExpressionValueGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 90, 3, 2, 3)).setObjects(*(("DISMAN-EXPRESSION-MIB", "expValueTimeTicksVal"), ("DISMAN-EXPRESSION-MIB", "expValueIpAddressVal"), ("DISMAN-EXPRESSION-MIB", "expValueInteger32Val"), ("DISMAN-EXPRESSION-MIB", "expValueOidVal"), ("DISMAN-EXPRESSION-MIB", "expValueUnsigned32Val"), ("DISMAN-EXPRESSION-MIB", "expValueCounter64Val"), ("DISMAN-EXPRESSION-MIB", "expValueCounter32Val"), ("DISMAN-EXPRESSION-MIB", "expValueOctetStringVal"), ) )
if mibBuilder.loadTexts: dismanExpressionValueGroup.setDescription("Expression value.")

# Compliances

dismanExpressionMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 90, 3, 1, 1)).setObjects(*(("DISMAN-EXPRESSION-MIB", "dismanExpressionDefinitionGroup"), ("DISMAN-EXPRESSION-MIB", "dismanExpressionResourceGroup"), ("DISMAN-EXPRESSION-MIB", "dismanExpressionValueGroup"), ) )
if mibBuilder.loadTexts: dismanExpressionMIBCompliance.setDescription("The compliance statement for entities which implement\nthe Expression MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("DISMAN-EXPRESSION-MIB", PYSNMP_MODULE_ID=dismanExpressionMIB)

# Objects
mibBuilder.exportSymbols("DISMAN-EXPRESSION-MIB", sysUpTimeInstance=sysUpTimeInstance, dismanExpressionMIB=dismanExpressionMIB, dismanExpressionMIBObjects=dismanExpressionMIBObjects, expResource=expResource, expResourceDeltaMinimum=expResourceDeltaMinimum, expResourceDeltaWildcardInstanceMaximum=expResourceDeltaWildcardInstanceMaximum, expResourceDeltaWildcardInstances=expResourceDeltaWildcardInstances, expResourceDeltaWildcardInstancesHigh=expResourceDeltaWildcardInstancesHigh, expResourceDeltaWildcardInstanceResourceLacks=expResourceDeltaWildcardInstanceResourceLacks, expDefine=expDefine, expExpressionTable=expExpressionTable, expExpressionEntry=expExpressionEntry, expExpressionOwner=expExpressionOwner, expExpressionName=expExpressionName, expExpression=expExpression, expExpressionValueType=expExpressionValueType, expExpressionComment=expExpressionComment, expExpressionDeltaInterval=expExpressionDeltaInterval, expExpressionPrefix=expExpressionPrefix, expExpressionErrors=expExpressionErrors, expExpressionEntryStatus=expExpressionEntryStatus, expErrorTable=expErrorTable, expErrorEntry=expErrorEntry, expErrorTime=expErrorTime, expErrorIndex=expErrorIndex, expErrorCode=expErrorCode, expErrorInstance=expErrorInstance, expObjectTable=expObjectTable, expObjectEntry=expObjectEntry, expObjectIndex=expObjectIndex, expObjectID=expObjectID, expObjectIDWildcard=expObjectIDWildcard, expObjectSampleType=expObjectSampleType, expObjectDeltaDiscontinuityID=expObjectDeltaDiscontinuityID, expObjectDiscontinuityIDWildcard=expObjectDiscontinuityIDWildcard, expObjectDiscontinuityIDType=expObjectDiscontinuityIDType, expObjectConditional=expObjectConditional, expObjectConditionalWildcard=expObjectConditionalWildcard, expObjectEntryStatus=expObjectEntryStatus, expValue=expValue, expValueTable=expValueTable, expValueEntry=expValueEntry, expValueInstance=expValueInstance, expValueCounter32Val=expValueCounter32Val, expValueUnsigned32Val=expValueUnsigned32Val, expValueTimeTicksVal=expValueTimeTicksVal, expValueInteger32Val=expValueInteger32Val, expValueIpAddressVal=expValueIpAddressVal, expValueOctetStringVal=expValueOctetStringVal, expValueOidVal=expValueOidVal, expValueCounter64Val=expValueCounter64Val, dismanExpressionMIBConformance=dismanExpressionMIBConformance, dismanExpressionMIBCompliances=dismanExpressionMIBCompliances, dismanExpressionMIBGroups=dismanExpressionMIBGroups)

# Groups
mibBuilder.exportSymbols("DISMAN-EXPRESSION-MIB", dismanExpressionResourceGroup=dismanExpressionResourceGroup, dismanExpressionDefinitionGroup=dismanExpressionDefinitionGroup, dismanExpressionValueGroup=dismanExpressionValueGroup)

# Compliances
mibBuilder.exportSymbols("DISMAN-EXPRESSION-MIB", dismanExpressionMIBCompliance=dismanExpressionMIBCompliance)
