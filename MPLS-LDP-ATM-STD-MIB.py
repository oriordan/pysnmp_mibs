# PySNMP SMI module. Autogenerated from smidump -f python MPLS-LDP-ATM-STD-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:58:04 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( AtmVpIdentifier, ) = mibBuilder.importSymbols("ATM-TC-MIB", "AtmVpIdentifier")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( mplsLdpEntityIndex, mplsLdpEntityLdpId, mplsLdpPeerLdpId, ) = mibBuilder.importSymbols("MPLS-LDP-STD-MIB", "mplsLdpEntityIndex", "mplsLdpEntityLdpId", "mplsLdpPeerLdpId")
( MplsAtmVcIdentifier, mplsStdMIB, ) = mibBuilder.importSymbols("MPLS-TC-STD-MIB", "MplsAtmVcIdentifier", "mplsStdMIB")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( RowStatus, StorageType, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType")

# Objects

mplsLdpAtmStdMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 166, 5)).setRevisions(("2004-06-03 00:00",))
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setOrganization("Multiprotocol Label Switching (mpls)\nWorking Group")
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setContactInfo("Joan Cucchiara (jcucchiara@mindspring.com)\nMarconi Communications, Inc.\n\nHans Sjostrand (hans@ipunplugged.com)\nipUnplugged\n\nJames V. Luciani (james_luciani@mindspring.com)\nMarconi Communications, Inc.\n\nWorking Group Chairs:\nGeorge Swallow,   email: swallow@cisco.com\nLoa Andersson,    email: loa@pi.se\n\nMPLS Working Group, email: mpls@uu.net")
if mibBuilder.loadTexts: mplsLdpAtmStdMIB.setDescription("Copyright (C) The Internet Society (2004). The\ninitial version of this MIB module was published\nin RFC 3815. For full legal notices see the RFC\nitself or see:\nhttp://www.ietf.org/copyrights/ianamib.html\n\nThis MIB contains managed object definitions for\nconfiguring and monitoring the Multiprotocol Label\nSwitching (MPLS), Label Distribution Protocol (LDP),\nutilizing Asynchronous Transfer Mode (ATM) as the Layer 2\nmedia.")
mplsLdpAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1))
mplsLdpEntityAtmObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1))
mplsLdpEntityAtmTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1))
if mibBuilder.loadTexts: mplsLdpEntityAtmTable.setDescription("This table contains ATM specific information\nwhich could be used in the\n'Optional Parameters' and other ATM specific\ninformation.\n\nThis table 'sparse augments' the mplsLdpEntityTable\nwhen ATM is the Layer 2 medium.")
mplsLdpEntityAtmEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1)).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"))
if mibBuilder.loadTexts: mplsLdpEntityAtmEntry.setDescription("An entry in this table represents the ATM parameters\nand ATM information for this LDP entity.")
mplsLdpEntityAtmIfIndexOrZero = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmIfIndexOrZero.setDescription("This value represents either the InterfaceIndex\nor 0 (zero).  The value of zero means that the\nInterfaceIndex is not known.\n\nHowever, if the InterfaceIndex is known, then it must\nbe represented by this value.\n\nIf an InterfaceIndex becomes known, then the\nnetwork management entity (e.g., SNMP agent) responsible\nfor this object MUST change the value from 0 (zero) to the\nvalue of the InterfaceIndex.  If an ATM Label is\nbeing used in forwarding data, then the value of this\nobject MUST be the InterfaceIndex.")
mplsLdpEntityAtmMergeCap = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 2), Integer().subtype(subtypeSpec=SingleValueConstraint(3,0,2,1,)).subtype(namedValues=NamedValues(("notSupported", 0), ("vpMerge", 1), ("vcMerge", 2), ("vpAndVcMerge", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmMergeCap.setDescription("Denotes the Merge Capability of this Entity.\nThis is the EXACT value for the ATM Session\nParameter, field M (for ATM Merge Capabilities).\nThe ATM Session Parameter is an optional\nparameter in the Initialization Message.\n\nThe description from rfc3036.txt is:\n\n'M, ATM Merge Capabilities\n   Specifies the merge capabilities of an ATM switch.  The\n   following values are supported in this version of the\n   specification:\n\n          Value          Meaning\n\n            0            Merge not supported\n            1            VP Merge supported\n            2            VC Merge supported\n            3            VP & VC Merge supported\n\n\n\n\n   If the merge capabilities of the LSRs differ, then:\n   -  Non-merge and VC-merge LSRs may freely interoperate.\n\n   -  The interoperability of VP-merge-capable switches\n      with non-VP-merge-capable switches is a subject\n      for future study.  When the LSRs differ on the\n      use of VP-merge, the session is established,\n      but VP merge is not used.'\n\n   Please refer to the following reference for a\n   complete description of this feature.")
mplsLdpEntityAtmLRComponents = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRComponents.setDescription("Number of Label Range Components in the Initialization\nmessage.  This also represents the number of entries\nin the mplsLdpEntityAtmLRTable which correspond\nto this entry.\n\nThis is the EXACT value for the ATM Session Parameter,\nfield N (for Number of label range components).\nThe ATM Session Parameter is an optional parameter\nin the Initialization Message.\n\nThe description from rfc3036.txt is:\n\n'N, Number of label range components\n   Specifies the number of ATM Label Range\n   Components included in the TLV.'\n\n Please refer to the following reference for\n a complete description of this feature.")
mplsLdpEntityAtmVcDirectionality = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(0,1,)).subtype(namedValues=NamedValues(("bidirectional", 0), ("unidirectional", 1), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmVcDirectionality.setDescription("If the value of this object is 'bidirectional(0)',\na given VCI, within a given VPI, is used as a\nlabel for both directions independently.\n\nIf the value of this object is 'unidirectional(1)',\na given VCI within a VPI designates one direction.\n\nThis is the EXACT value for the ATM Session Parameter,\nfield D (for VC Directionality).  The ATM Session\nParameter is an optional parameter in the\nInitialization Message.\n\nThe description from rfc3036.txt is:\n\n'D, VC Directionality\n   A value of 0 specifies bidirectional VC capability,\n   meaning the LSR can (within a given VPI) support\n   the use of a given VCI as a label for both link\n   directions independently.  A value of 1\n   specifies unidirectional VC capability, meaning\n   (within a given VPI) a given VCI may appear in\n   a label mapping for one direction on the link\n   only.  When either or both of the peers\n   specifies unidirectional VC capability, both\n   LSRs use unidirectional VC label assignment for\n   the link as follows.  The LSRs compare their\n   LDP Identifiers as unsigned integers.  The LSR\n   with the larger LDP Identifier may assign\n   only odd-numbered VCIs in the VPI/VCI\n   range as labels.  The system with the smaller\n   LDP Identifier may assign only even-numbered\n   VCIs in the VPI/VCI range as labels.'\n\n   Please refer to the following reference\n   for a complete description of this feature.")
mplsLdpEntityAtmLsrConnectivity = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 5), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("direct", 1), ("indirect", 2), )).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLsrConnectivity.setDescription("The peer LSR may be connected indirectly by means\nof an ATM VP so that the VPI values may be different\non either endpoint so the label MUST be encoded\nentirely within the VCI field.")
mplsLdpEntityAtmDefaultControlVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 6), AtmVpIdentifier().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVpi.setDescription("The default VPI value for the non-MPLS connection.  The\ndefault value of this is 0 (zero) but other values may\nbe configured.  This object allows a different value\nto be configured.")
mplsLdpEntityAtmDefaultControlVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 7), MplsAtmVcIdentifier().clone('32')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmDefaultControlVci.setDescription("The Default VCI value for a non-MPLS connection.  The\ndefault value of this is 32 but other values may be\nconfigured.  This object allows a different value to\nbe configured.")
mplsLdpEntityAtmUnlabTrafVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 8), AtmVpIdentifier().clone('0')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVpi.setDescription("VPI value of the VCC supporting unlabeled traffic.  This\nnon-MPLS connection is used to carry unlabeled (IP)\npackets.  The default value is the same as the default\nvalue of the 'mplsLdpEntityAtmDefaultControlVpi', however\nanother value may be configured.")
mplsLdpEntityAtmUnlabTrafVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 9), MplsAtmVcIdentifier().clone('32')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmUnlabTrafVci.setDescription("VCI value of the VCC supporting unlabeled traffic.\nThis non-MPLS connection is used to carry unlabeled (IP)\npackets. The default value is the same as the default\nvalue of the 'mplsLdpEntityAtmDefaultControlVci', however\nanother value may be configured.")
mplsLdpEntityAtmStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 10), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmStorageType.setDescription("The storage type for this conceptual row.\nConceptual rows having the value 'permanent(4)'\nneed not allow write-access to any columnar\nobjects in the row.")
mplsLdpEntityAtmRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmRowStatus.setDescription("The status of this conceptual row.  All writable\nobjects in this row may be modified at any time,\nhowever, as described in detail in the section\nentitled, 'Changing Values After Session\nEstablishment', and again described in the\nDESCRIPTION clause of the mplsLdpEntityAdminStatus\nobject, if a session has been initiated with a Peer,\nchanging objects in this table will wreak havoc\nwith the session and interrupt traffic.  To repeat again:\nthe recommended procedure is to set the\nmplsLdpEntityAdminStatus to down, thereby explicitly\ncausing a session to be torn down. Then,\nchange objects in this entry, then set the\nmplsLdpEntityAdminStatus to enable\nwhich enables a new session to be initiated.")
mplsLdpEntityAtmLRTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2))
if mibBuilder.loadTexts: mplsLdpEntityAtmLRTable.setDescription("The MPLS LDP Entity ATM Label Range (LR) Table.\nThe purpose of this table is to provide a mechanism\nfor configuring a contiguous range of vpi's\nwith a contiguous range of vci's, or a 'label range'\nfor LDP Entities.\n\nLDP Entities which use ATM must have at least one\nentry in this table.\n\nThere must exist at least one entry in this\ntable for every LDP Entity that has\n'mplsLdpEntityOptionalParameters' object with\na value of 'atmSessionParameters'.")
mplsLdpEntityAtmLREntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1)).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMinVpi"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMinVci"))
if mibBuilder.loadTexts: mplsLdpEntityAtmLREntry.setDescription("A row in the LDP Entity ATM Label\nRange Table.  One entry in this table contains\ninformation on a single range of labels\nrepresented by the configured Upper and Lower\nBounds VPI/VCI pairs.  These are the same\ndata used in the Initialization Message.\n\nNOTE:  The ranges for a specific LDP Entity\nare UNIQUE and non-overlapping.  For example,\nfor a specific LDP Entity index, there could\nbe one entry having LowerBound vpi/vci == 0/32, and\nUpperBound vpi/vci == 0/100, and a second entry\nfor this same interface with LowerBound\nvpi/vci == 0/101 and UpperBound vpi/vci == 0/200.\nHowever, there could not be a third entry with\nLowerBound vpi/vci == 0/200 and\nUpperBound vpi/vci == 0/300 because this label\nrange overlaps with the second entry (i.e., both\nentries now have 0/200).\n\n\n\nA row will not become active unless a unique and\nnon-overlapping range is specified.\n\nAt least one label range entry for a\nspecific LDP Entity MUST\ninclude the default VPI/VCI  values denoted\nin the LDP Entity Table.\n\nA request to create a row with an overlapping\nrange should result in an inconsistentValue\nerror.")
mplsLdpEntityAtmLRMinVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 1), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVpi.setDescription("The minimum VPI number configured for this range.\nThe value of zero is a valid value for the VPI portion\nof the label.")
mplsLdpEntityAtmLRMinVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 2), MplsAtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMinVci.setDescription("The minimum VCI number configured for this range.")
mplsLdpEntityAtmLRMaxVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 3), AtmVpIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVpi.setDescription("The maximum VPI number configured for this range.")
mplsLdpEntityAtmLRMaxVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRMaxVci.setDescription("The maximum VCI number configured for this range.")
mplsLdpEntityAtmLRStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRStorageType.setDescription("The storage type for this conceptual row.\nConceptual rows having the value 'permanent(4)'\nneed not allow write-access to any columnar\nobjects in the row.")
mplsLdpEntityAtmLRRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 1, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mplsLdpEntityAtmLRRowStatus.setDescription("The status of this conceptual row.  All writable\nobjects in this row may be modified at any time,\nhowever, as described in detail in the section\nentitled, 'Changing Values After Session\nEstablishment', and again described in the\nDESCRIPTION clause of the\nmplsLdpEntityAdminStatus object,\nif a session has been initiated with a Peer,\nchanging objects in this table will\nwreak havoc with the session and interrupt traffic.\nTo repeat again:  the recommended procedure\nis to set the mplsLdpEntityAdminStatus to\ndown, thereby explicitly causing a session\nto be torn down. Then, change objects in this\nentry, then set the mplsLdpEntityAdminStatus\nto enable which enables a new session\nto be initiated.")
mplsLdpAtmSessionObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2))
mplsLdpAtmSessionTable = MibTable((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1))
if mibBuilder.loadTexts: mplsLdpAtmSessionTable.setDescription("A table which relates sessions in the\n'mplsLdpSessionTable' and their label\nrange intersections.  There could be one\nor more label range intersections between an\nLDP Entity and LDP Peer using ATM as the\nunderlying  media.  Each row represents\na single label range intersection.\n\nThis table cannot use the 'AUGMENTS'\nclause because there is not necessarily\na one-to-one mapping between this table\nand the mplsLdpSessionTable.")
mplsLdpAtmSessionEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1)).setIndexNames((0, "MPLS-LDP-STD-MIB", "mplsLdpEntityLdpId"), (0, "MPLS-LDP-STD-MIB", "mplsLdpEntityIndex"), (0, "MPLS-LDP-STD-MIB", "mplsLdpPeerLdpId"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRLowerBoundVpi"), (0, "MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRLowerBoundVci"))
if mibBuilder.loadTexts: mplsLdpAtmSessionEntry.setDescription("An entry in this table represents information on a\nsingle label range intersection between an LDP Entity\nand LDP Peer.\n\nThe information contained in a row is read-only.")
mplsLdpSessionAtmLRLowerBoundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 1), AtmVpIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVpi.setDescription("The minimum VPI number for this range.")
mplsLdpSessionAtmLRLowerBoundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 2), MplsAtmVcIdentifier()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRLowerBoundVci.setDescription("The minimum VCI number for this range.")
mplsLdpSessionAtmLRUpperBoundVpi = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 3), AtmVpIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVpi.setDescription("The maximum VPI number for this range.")
mplsLdpSessionAtmLRUpperBoundVci = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 166, 5, 1, 2, 1, 1, 4), MplsAtmVcIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mplsLdpSessionAtmLRUpperBoundVci.setDescription("The maximum VCI number for this range.")
mplsLdpAtmConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2))
mplsLdpAtmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 1))
mplsLdpAtmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2))

# Augmentions

# Groups

mplsLdpAtmGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 1, 1)).setObjects(*(("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmMergeCap"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLsrConnectivity"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRComponents"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMaxVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmDefaultControlVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmRowStatus"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmUnlabTrafVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRUpperBoundVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmDefaultControlVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmUnlabTrafVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRRowStatus"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRStorageType"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmIfIndexOrZero"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpSessionAtmLRUpperBoundVci"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmLRMaxVpi"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmVcDirectionality"), ("MPLS-LDP-ATM-STD-MIB", "mplsLdpEntityAtmStorageType"), ) )
if mibBuilder.loadTexts: mplsLdpAtmGroup.setDescription("Objects that apply to all MPLS LDP implementations\nusing ATM as the Layer 2.")

# Compliances

mplsLdpAtmModuleFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2, 1)).setObjects(*(("MPLS-LDP-ATM-STD-MIB", "mplsLdpAtmGroup"), ) )
if mibBuilder.loadTexts: mplsLdpAtmModuleFullCompliance.setDescription("The Module is implemented with support for\nread-create and read-write.  In other words,\nboth monitoring and configuration\nare available when using this MODULE-COMPLIANCE.")
mplsLdpAtmModuleReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 166, 5, 2, 2, 2)).setObjects(*(("MPLS-LDP-ATM-STD-MIB", "mplsLdpAtmGroup"), ) )
if mibBuilder.loadTexts: mplsLdpAtmModuleReadOnlyCompliance.setDescription("The Module is implemented with support for\nread-only.  In other words, only monitoring\nis available by implementing this MODULE-COMPLIANCE.")

# Exports

# Module identity
mibBuilder.exportSymbols("MPLS-LDP-ATM-STD-MIB", PYSNMP_MODULE_ID=mplsLdpAtmStdMIB)

# Objects
mibBuilder.exportSymbols("MPLS-LDP-ATM-STD-MIB", mplsLdpAtmStdMIB=mplsLdpAtmStdMIB, mplsLdpAtmObjects=mplsLdpAtmObjects, mplsLdpEntityAtmObjects=mplsLdpEntityAtmObjects, mplsLdpEntityAtmTable=mplsLdpEntityAtmTable, mplsLdpEntityAtmEntry=mplsLdpEntityAtmEntry, mplsLdpEntityAtmIfIndexOrZero=mplsLdpEntityAtmIfIndexOrZero, mplsLdpEntityAtmMergeCap=mplsLdpEntityAtmMergeCap, mplsLdpEntityAtmLRComponents=mplsLdpEntityAtmLRComponents, mplsLdpEntityAtmVcDirectionality=mplsLdpEntityAtmVcDirectionality, mplsLdpEntityAtmLsrConnectivity=mplsLdpEntityAtmLsrConnectivity, mplsLdpEntityAtmDefaultControlVpi=mplsLdpEntityAtmDefaultControlVpi, mplsLdpEntityAtmDefaultControlVci=mplsLdpEntityAtmDefaultControlVci, mplsLdpEntityAtmUnlabTrafVpi=mplsLdpEntityAtmUnlabTrafVpi, mplsLdpEntityAtmUnlabTrafVci=mplsLdpEntityAtmUnlabTrafVci, mplsLdpEntityAtmStorageType=mplsLdpEntityAtmStorageType, mplsLdpEntityAtmRowStatus=mplsLdpEntityAtmRowStatus, mplsLdpEntityAtmLRTable=mplsLdpEntityAtmLRTable, mplsLdpEntityAtmLREntry=mplsLdpEntityAtmLREntry, mplsLdpEntityAtmLRMinVpi=mplsLdpEntityAtmLRMinVpi, mplsLdpEntityAtmLRMinVci=mplsLdpEntityAtmLRMinVci, mplsLdpEntityAtmLRMaxVpi=mplsLdpEntityAtmLRMaxVpi, mplsLdpEntityAtmLRMaxVci=mplsLdpEntityAtmLRMaxVci, mplsLdpEntityAtmLRStorageType=mplsLdpEntityAtmLRStorageType, mplsLdpEntityAtmLRRowStatus=mplsLdpEntityAtmLRRowStatus, mplsLdpAtmSessionObjects=mplsLdpAtmSessionObjects, mplsLdpAtmSessionTable=mplsLdpAtmSessionTable, mplsLdpAtmSessionEntry=mplsLdpAtmSessionEntry, mplsLdpSessionAtmLRLowerBoundVpi=mplsLdpSessionAtmLRLowerBoundVpi, mplsLdpSessionAtmLRLowerBoundVci=mplsLdpSessionAtmLRLowerBoundVci, mplsLdpSessionAtmLRUpperBoundVpi=mplsLdpSessionAtmLRUpperBoundVpi, mplsLdpSessionAtmLRUpperBoundVci=mplsLdpSessionAtmLRUpperBoundVci, mplsLdpAtmConformance=mplsLdpAtmConformance, mplsLdpAtmGroups=mplsLdpAtmGroups, mplsLdpAtmCompliances=mplsLdpAtmCompliances)

# Groups
mibBuilder.exportSymbols("MPLS-LDP-ATM-STD-MIB", mplsLdpAtmGroup=mplsLdpAtmGroup)

# Compliances
mibBuilder.exportSymbols("MPLS-LDP-ATM-STD-MIB", mplsLdpAtmModuleFullCompliance=mplsLdpAtmModuleFullCompliance, mplsLdpAtmModuleReadOnlyCompliance=mplsLdpAtmModuleReadOnlyCompliance)
