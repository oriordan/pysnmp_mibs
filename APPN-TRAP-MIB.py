# PySNMP SMI module. Autogenerated from smidump -f python APPN-TRAP-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:57:31 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( dlurDlusSessnStatus, ) = mibBuilder.importSymbols("APPN-DLUR-MIB", "dlurDlusSessnStatus")
( appnCompliances, appnGroups, appnIsInP2SFmdBytes, appnIsInP2SFmdPius, appnIsInP2SNonFmdBytes, appnIsInP2SNonFmdPius, appnIsInS2PFmdBytes, appnIsInS2PFmdPius, appnIsInS2PNonFmdBytes, appnIsInS2PNonFmdPius, appnIsInSessUpTime, appnLocalTgCpCpSession, appnLocalTgOperational, appnLsOperState, appnMIB, appnObjects, appnPortOperState, ) = mibBuilder.importSymbols("APPN-MIB", "appnCompliances", "appnGroups", "appnIsInP2SFmdBytes", "appnIsInP2SFmdPius", "appnIsInP2SNonFmdBytes", "appnIsInP2SNonFmdPius", "appnIsInS2PFmdBytes", "appnIsInS2PFmdPius", "appnIsInS2PNonFmdBytes", "appnIsInS2PNonFmdPius", "appnIsInSessUpTime", "appnLocalTgCpCpSession", "appnLocalTgOperational", "appnLsOperState", "appnMIB", "appnObjects", "appnPortOperState")
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Integer32, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks")

# Objects

appnTrapMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 34, 4, 0)).setRevisions(("1998-08-31 00:00",))
if mibBuilder.loadTexts: appnTrapMIB.setOrganization("IETF SNA NAU MIB WG / AIW APPN MIBs SIG")
if mibBuilder.loadTexts: appnTrapMIB.setContactInfo("\nBob Clouston\nCisco Systems\n7025 Kit Creek Road\nP.O. Box 14987\nResearch Triangle Park, NC 27709, USA\nTel:    1 919 472 2333\nE-mail: clouston@cisco.com\n\nBob Moore\nIBM Corporation\n4205 S. Miami Boulevard\nBRQA/501\nP.O. Box 12195\nResearch Triangle Park, NC 27709, USA\nTel:    1 919 254 4436\nE-mail: remoore@us.ibm.com")
if mibBuilder.loadTexts: appnTrapMIB.setDescription("This MIB module defines notifications to be generated by\nnetwork devices with APPN capabilities.  It presupposes\nsupport for the APPN MIB.  It also presupposes\nsupport for the DLUR MIB for implementations\nthat support the DLUR-related groups.")
appnTrapObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 34, 4, 1, 7))
appnTrapControl = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 7, 1), Bits().subtype(namedValues=NamedValues(("appnLocalTgOperStateChangeTrap", 0), ("appnLocalTgCpCpChangeTrap", 1), ("appnPortOperStateChangeTrap", 2), ("appnLsOperStateChangeTrap", 3), ("dlurDlusStateChangeTrap", 4), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: appnTrapControl.setDescription("An object to turn APPN notification generation on and off.\nSetting a notification type's bit to 1 enables generation of\nnotifications of that type, subject to further filtering\nresulting from entries in the snmpNotificationMIB.  Setting\nthis bit to 0 disables generation of notifications of that\ntype.\n\nNote that generation of the appnIsrAccountingDataTrap is\ncontrolled by the appnIsInGlobeCtrAdminStatus object in\nthe APPN MIB:  if counts of intermediate session traffic\nare being kept at all, then the notification is also enabled.")
appnLocalTgTableChanges = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLocalTgTableChanges.setDescription("A count of the number of times a row in the appnLocalTgTable\nhas changed status since the APPN node was last reinitialized.\nThis counter is incremented whenever a condition is detected\nthat would cause a appnLocalTgOperStateChangeTrap or\nappnLocalTgCpCpChangeTrap notification to be sent, whether\nor not those notifications are enabled.")
appnPortTableChanges = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnPortTableChanges.setDescription("A count of the number of times a row in the appnPortTable\nhas changed status since the APPN node was last reinitialized.\nThis counter is incremented whenever a condition is detected\nthat would cause a appnPortOperStateChangeTrap notification\nto be sent, whether or not this notification is enabled.")
appnLsTableChanges = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: appnLsTableChanges.setDescription("A count of the number of times a row in the appnLsTable\nhas changed status since the APPN node was last reinitialized.\nThis counter is incremented whenever a condition is detected\nthat would cause a appnLsOperStateChangeTrap notification\nto be sent, whether or not this notification is enabled.")
dlurDlusTableChanges = MibScalar((1, 3, 6, 1, 2, 1, 34, 4, 1, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dlurDlusTableChanges.setDescription("A count of the number of times a row in the dlurDlusTable\nhas changed status since the APPN node was last reinitialized.\nThis counter is incremented whenever a condition is detected\nthat would cause a dlurDlusStateChangeTrap notification\nto be sent, whether or not this notification is enabled.")

# Augmentions

# Notifications

appnIsrAccountingDataTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 0, 1)).setObjects(*(("APPN-MIB", "appnIsInSessUpTime"), ("APPN-MIB", "appnIsInS2PNonFmdPius"), ("APPN-MIB", "appnIsInP2SNonFmdPius"), ("APPN-MIB", "appnIsInP2SFmdBytes"), ("APPN-MIB", "appnIsInP2SFmdPius"), ("APPN-MIB", "appnIsInS2PNonFmdBytes"), ("APPN-MIB", "appnIsInS2PFmdBytes"), ("APPN-MIB", "appnIsInS2PFmdPius"), ("APPN-MIB", "appnIsInP2SNonFmdBytes"), ) )
if mibBuilder.loadTexts: appnIsrAccountingDataTrap.setDescription("When it has been enabled, this notification is generated by an\nAPPN node whenever an ISR session passing through the node is\ntaken down, regardless of whether the session went down\nnormally or abnormally.  Its purpose is to allow a management\napplication (primarily an accounting application) that is\nmonitoring the ISR counts to receive the final values of these\ncounts, so that the application can properly account for the\namounts the counts were incremented since the last time the\napplication polled them.  The appnIsInSessUpTime object\nprovides the total amount of time that the session was active.\n\nThis notification is not a substitute for polling the ISR\ncounts.  In particular, the count values reported in this\nnotification cannot be assumed to be the complete totals for\nthe life of the session, since they may have wrapped while the\nsession was up.\n\nThe session to which the objects in this notification apply is\nidentified by the fully qualified CP name and PCID that make up\nthe table index.  An instance of this notification will contain\nexactly one instance of each of its objects, and these objects\nwill all belong to the same conceptual row of the\nappnIsInTable.\n\nGeneration of this notification is controlled by the same\nobject in the APPN MIB, appnIsInGlobeCtrAdminStatus, that\ncontrols whether the count objects themselves are being\nincremented.")
appnLocalTgOperStateChangeTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 0, 2)).setObjects(*(("APPN-TRAP-MIB", "appnLocalTgTableChanges"), ("APPN-MIB", "appnLocalTgOperational"), ) )
if mibBuilder.loadTexts: appnLocalTgOperStateChangeTrap.setDescription("When it has been enabled, this notification makes it possible\nfor an APPN topology application to get asynchronous\nnotifications of local TG operational state changes,\nand thus to reduce the frequency with which it polls\nfor these changes.\n\nThis notification is sent whenever there is a change to\nthe appnLocalTgOperational object in a row of the\nappnLocalTgTable.  This notification is only sent for row\ncreation if the row is created with a value of 'true' for\nappnLocalTgOperational.  This notification is only sent for\nrow deletion if the last value of appnLocalTgOperational was\n'true'.  In this case, the value of appnLocalTgOperational\nin the notification shall be 'false', since the deletion of\na row indicates that the TG is no longer operational.\n\nThe notification is more than a simple 'poll me now' indication.\nIt carries both a count of local TG topology changes, and the\ncurrent operational state itself.  The count of changes allows an\napplication to detect lost notifications, either when polling\nor upon receiving a subsequent notification, at which point it\nknows it must retrieve the entire appnLocalTgTable again.\nThis is the same count as used in the appnLocalCpCpStateChangeTrap.\nA lost notification could indicate a local TG CP-CP session state\nchange or an operational state change.\n\nGeneration of this notification is controlled by the\nappnTrapControl object.")
appnLocalTgCpCpChangeTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 0, 3)).setObjects(*(("APPN-TRAP-MIB", "appnLocalTgTableChanges"), ("APPN-MIB", "appnLocalTgCpCpSession"), ) )
if mibBuilder.loadTexts: appnLocalTgCpCpChangeTrap.setDescription("When it has been enabled, this notification makes it possible\nfor an APPN topology application to get asynchronous\nnotifications of local TG control-point to control-point (CP-CP)\nsession state changes, and thus to reduce the\nfrequency with which it polls for these changes.\n\nThis notification is sent whenever there is a change to\nthe appnLocalTgCpCpSession object but NOT the\nappnLocalTgOperational object in a row of the appnLocalTgTable.\nThis notification is never sent for appnLocalTgTable row\ncreation or deletion.\n\nThe notification is more than a simple 'poll me now' indication.\nIt carries both a count of local TG topology changes, and the\ncurrent CP-CP session state itself.  The count of changes allows\nan application to detect lost notifications, either when polling\nor upon receiving a subsequent notification, at which point it\nknows it must retrieve the entire appnLocalTgTable again.  This\nis the same count as used in the appnLocalTgOperStateChangeTrap.\nA lost notification could indicate a local TG CP-CP session\nstate change or an operational state change.\n\nGeneration of this notification is controlled by the\nappnTrapControl object.")
appnPortOperStateChangeTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 0, 4)).setObjects(*(("APPN-MIB", "appnPortOperState"), ("APPN-TRAP-MIB", "appnPortTableChanges"), ) )
if mibBuilder.loadTexts: appnPortOperStateChangeTrap.setDescription("When it has been enabled, this notification makes it possible\nfor an APPN topology application to get asynchronous\nnotifications of port operational state changes, and thus to\nreduce the frequency with which it polls for these changes.\nThis notification is only sent when a appnPortOperState has\ntransitioned to a value of 'active' or 'inactive'.\n\nThis notification is sent whenever there is a appnPortOperState\nobject transition to 'inactive' or 'active' state in the\nappnPortTable.  This notification is only sent for row creation\nif the row is created with a value of 'active' for\nappnPortOperState.  This notification is only sent for\nrow deletion if the last value of appnPortOperState was\n'active'.  In this case, the value of appnPortOperState\nin the notification shall be 'inactive', since the deletion of\na row indicates that the port is no longer active.\n\nThe notification is more than a simple 'poll me now' indication.\nIt carries both a count of port table changes, and the\noperational state itself.  The count of changes allows an\napplication to detect lost notifications, either when polling\nor upon receiving a subsequent notification, at which point\nit knows it must retrieve the entire appnPortTable again.\n\nGeneration of this notification is controlled by the\nappnTrapControl object.")
appnLsOperStateChangeTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 0, 5)).setObjects(*(("APPN-MIB", "appnLsOperState"), ("APPN-TRAP-MIB", "appnLsTableChanges"), ) )
if mibBuilder.loadTexts: appnLsOperStateChangeTrap.setDescription("When it has been enabled, this notification makes it possible\nfor an APPN topology application to get asynchronous\nnotifications of link station operational state changes, and\nthus to reduce the frequency with which it polls for these\nchanges.  This notification is only sent when a appnLsOperState\nhas transitioned to a value of 'active' or 'inactive'.\n\nThis notification is sent whenever there is a appnLsOperState\nobject transition to 'inactive' or 'active' state in the\nappnLsTable.  This notification is only sent for row creation\nif the row is created with a value of 'active' for\nappnLsOperState.  This notification is only sent for\nrow deletion if the last value of appnLsOperState was\n'active'.  In this case, the value of appnLsOperState\nin the notification shall be 'inactive', since the deletion of\na row indicates that the link station is no longer active.\n\nThe notification is more than a simple 'poll me now' indication.\nIt carries both a count of link station table changes, and the\noperational state itself.  The count of changes allows an\napplication to detect lost notifications, either when polling\nor upon receiving a subsequent notification, at which point it\nknows it must retrieve the entire appnLsTable again.\n\nGeneration of this notification is controlled by the\nappnTrapControl object.")
dlurDlusStateChangeTrap = NotificationType((1, 3, 6, 1, 2, 1, 34, 4, 0, 6)).setObjects(*(("APPN-DLUR-MIB", "dlurDlusSessnStatus"), ("APPN-TRAP-MIB", "dlurDlusTableChanges"), ) )
if mibBuilder.loadTexts: dlurDlusStateChangeTrap.setDescription("When it has been enabled, this notification makes it possible\nfor an APPN topology application to get asynchronous\nnotifications of DLUR-DLUS session changes, and thus to reduce\nthe frequency with which it polls for these changes.\n\nThis notification is sent whenever there is a dlurDlusSessnStatus\nobject transition to 'inactive' or 'active' state in the\ndlurDlusTable.  This notification is only sent for row creation\nif the row is created with a value of 'active' for\ndlurDlusSessnStatus.  This notification is only sent for\nrow deletion if the last value of dlurDlusSessnStatus was\n'active'.  In this case, the value of dlurDlusSessnStatus\nin the notification shall be 'inactive', since the deletion of\na row indicates that the session is no longer active.\n\nThe notification is more than a simple 'poll me now' indication.\nIt carries both a count of DLUR-DLUS table changes, and the\nsession status itself.  The count of changes allows an\napplication to detect lost notifications, either when polling\nor upon receiving a subsequent notification, at which point it\nknows it must retrieve the entire dlurDlusTable again.\n\nGeneration of this notification is controlled by the\nappnTrapControl object.")

# Groups

appnTrapMibIsrNotifGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 21)).setObjects(*(("APPN-TRAP-MIB", "appnIsrAccountingDataTrap"), ) )
if mibBuilder.loadTexts: appnTrapMibIsrNotifGroup.setDescription("A notification for reporting the final values of the\nAPPN MIB's ISR counters.")
appnTrapMibTopoConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 22)).setObjects(*(("APPN-TRAP-MIB", "appnTrapControl"), ("APPN-TRAP-MIB", "appnLocalTgTableChanges"), ("APPN-TRAP-MIB", "appnPortTableChanges"), ("APPN-TRAP-MIB", "appnLsTableChanges"), ) )
if mibBuilder.loadTexts: appnTrapMibTopoConfGroup.setDescription("A collection of objects for reducing the polling\nassociated with the local topology tables in the\nAPPN MIB.  Nodes that implement this group SHALL\nalso implement the appnTrapMibTopoNotifGroup.")
appnTrapMibTopoNotifGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 23)).setObjects(*(("APPN-TRAP-MIB", "appnLocalTgCpCpChangeTrap"), ("APPN-TRAP-MIB", "appnLocalTgOperStateChangeTrap"), ("APPN-TRAP-MIB", "appnLsOperStateChangeTrap"), ("APPN-TRAP-MIB", "appnPortOperStateChangeTrap"), ) )
if mibBuilder.loadTexts: appnTrapMibTopoNotifGroup.setDescription("A collection of notifications for reducing the polling\nassociated with the local topology tables in the\nAPPN MIB.  Nodes that implement this group SHALL\nalso implement the appnTrapMibTopoConfGroup.")
appnTrapMibDlurConfGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 24)).setObjects(*(("APPN-TRAP-MIB", "appnTrapControl"), ("APPN-TRAP-MIB", "dlurDlusTableChanges"), ) )
if mibBuilder.loadTexts: appnTrapMibDlurConfGroup.setDescription("A collection of objects for reducing the polling\nassociated with the dlurDlusTable in the DLUR\nMIB.  Nodes that implement this group SHALL also\nimplement the appnTrapMibDlurNotifGroup.")
appnTrapMibDlurNotifGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 34, 4, 3, 2, 25)).setObjects(*(("APPN-TRAP-MIB", "dlurDlusStateChangeTrap"), ) )
if mibBuilder.loadTexts: appnTrapMibDlurNotifGroup.setDescription("A notification for reducing the polling associated\nwith the dlurDlusTable in the DLUR MIB.  Nodes that\nimplement this group SHALL also implement the\nappnTrapMibDlurConfGroup.")

# Compliances

appnTrapMibCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 34, 4, 3, 1, 2)).setObjects(*(("APPN-TRAP-MIB", "appnTrapMibDlurConfGroup"), ("APPN-TRAP-MIB", "appnTrapMibIsrNotifGroup"), ("APPN-TRAP-MIB", "appnTrapMibTopoNotifGroup"), ("APPN-TRAP-MIB", "appnTrapMibDlurNotifGroup"), ("APPN-TRAP-MIB", "appnTrapMibTopoConfGroup"), ) )
if mibBuilder.loadTexts: appnTrapMibCompliance.setDescription("The compliance statement for the SNMP entities that\nimplement the APPN-TRAP-MIB.")

# Exports

# Module identity
mibBuilder.exportSymbols("APPN-TRAP-MIB", PYSNMP_MODULE_ID=appnTrapMIB)

# Objects
mibBuilder.exportSymbols("APPN-TRAP-MIB", appnTrapMIB=appnTrapMIB, appnTrapObjects=appnTrapObjects, appnTrapControl=appnTrapControl, appnLocalTgTableChanges=appnLocalTgTableChanges, appnPortTableChanges=appnPortTableChanges, appnLsTableChanges=appnLsTableChanges, dlurDlusTableChanges=dlurDlusTableChanges)

# Notifications
mibBuilder.exportSymbols("APPN-TRAP-MIB", appnIsrAccountingDataTrap=appnIsrAccountingDataTrap, appnLocalTgOperStateChangeTrap=appnLocalTgOperStateChangeTrap, appnLocalTgCpCpChangeTrap=appnLocalTgCpCpChangeTrap, appnPortOperStateChangeTrap=appnPortOperStateChangeTrap, appnLsOperStateChangeTrap=appnLsOperStateChangeTrap, dlurDlusStateChangeTrap=dlurDlusStateChangeTrap)

# Groups
mibBuilder.exportSymbols("APPN-TRAP-MIB", appnTrapMibIsrNotifGroup=appnTrapMibIsrNotifGroup, appnTrapMibTopoConfGroup=appnTrapMibTopoConfGroup, appnTrapMibTopoNotifGroup=appnTrapMibTopoNotifGroup, appnTrapMibDlurConfGroup=appnTrapMibDlurConfGroup, appnTrapMibDlurNotifGroup=appnTrapMibDlurNotifGroup)

# Compliances
mibBuilder.exportSymbols("APPN-TRAP-MIB", appnTrapMibCompliance=appnTrapMibCompliance)
