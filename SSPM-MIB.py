# PySNMP SMI module. Autogenerated from smidump -f python SSPM-MIB
# by libsmi2pysnmp-0.1.3 at Thu May 22 11:58:14 2014,
# Python version sys.version_info(major=2, minor=7, micro=2, releaselevel='final', serial=0)

# Imports

( AppLocalIndex, ) = mibBuilder.importSymbols("APM-MIB", "AppLocalIndex")
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( InterfaceIndexOrZero, ) = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
( InetAddress, InetAddressType, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
( OwnerString, rmon, ) = mibBuilder.importSymbols("RMON-MIB", "OwnerString", "rmon")
( ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup")
( Bits, Counter32, Integer32, Integer32, ModuleIdentity, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Integer32", "Integer32", "ModuleIdentity", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( RowStatus, StorageType, TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "StorageType", "TextualConvention", "TruthValue")
( Utf8String, ) = mibBuilder.importSymbols("SYSAPPL-MIB", "Utf8String")

# Types

class SspmClockMaxSkew(TextualConvention, Integer32):
    displayHint = "d"
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(1,65535)
    
class SspmClockSource(TextualConvention, Integer32):
    displayHint = "d"
    subtypeSpec = Integer32.subtypeSpec+ValueRangeConstraint(0,255)
    
class SspmMicroSeconds(TextualConvention, Unsigned32):
    displayHint = "d"
    

# Objects

sspmMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 16, 28)).setRevisions(("2005-07-28 00:00",))
if mibBuilder.loadTexts: sspmMIB.setOrganization("IETF RMON MIB working group")
if mibBuilder.loadTexts: sspmMIB.setContactInfo("        Carl W. Kalbfleisch\nConsultant\n\nE-mail: ietf@kalbfleisch.us\n\nWorking group mailing list: rmonmib@ietf.org\nTo subscribe send email to rmonmib-request@ietf.org")
if mibBuilder.loadTexts: sspmMIB.setDescription("This SSPM MIB module is applicable to probes\nimplementing Synthetic Source for Performance\nMonitoring functions.\n\nCopyright (C) The Internet Society (2005).  This version\nof this MIB module is part of RFC 4149; see the RFC\nitself for full legal notices.")
sspmMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1))
sspmGeneral = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 1))
sspmGeneralClockResolution = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 1), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockResolution.setDescription("A read-only variable indicating the resolution\nof the measurements possible by this device.")
sspmGeneralClockMaxSkew = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 2), SspmClockMaxSkew()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockMaxSkew.setDescription("A read-only variable indicating the maximum offset\nerror due to skew of the local clock over the\ntime interval 86400 seconds, in seconds.")
sspmGeneralClockSource = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 3), SspmClockSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralClockSource.setDescription("A read-only variable indicating the source of the clock.\nThis is provided to allow a user to determine how accurate\nthe timing mechanism is compared with other devices.  This\nis needed for the coordination of time values\nbetween probes for one-way measurements.")
sspmGeneralMinFrequency = MibScalar((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 4), SspmMicroSeconds()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmGeneralMinFrequency.setDescription("A read-only variable that indicates the devices'\ncapability for the minimum supported\nsspmSourceFrequency.  If sspmSourceFrequency is\nset to a value lower than the value reported\nby this attribute, then the set of sspmSourceFrequency\nwill fail with an inconsistent value error.")
sspmCapabilitiesTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5))
if mibBuilder.loadTexts: sspmCapabilitiesTable.setDescription("The table of SSPM capabilities.")
sspmCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5, 1)).setIndexNames((0, "SSPM-MIB", "sspmCapabilitiesInstance"))
if mibBuilder.loadTexts: sspmCapabilitiesEntry.setDescription("Details about a particular SSPM capability.")
sspmCapabilitiesInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 1, 5, 1, 1), AppLocalIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmCapabilitiesInstance.setDescription("Indicates whether SSPM configuration of the corresponding\nAppLocalIndex is supported by this device.  Generally,\nentries in this table are only made by the device when the\nconfiguration of the measurement is available.")
sspmSource = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 2))
sspmSourceProfileTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1))
if mibBuilder.loadTexts: sspmSourceProfileTable.setDescription("The table of SSPM Source Profiles configured.")
sspmSourceProfileEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1)).setIndexNames((0, "SSPM-MIB", "sspmSourceProfileInstance"))
if mibBuilder.loadTexts: sspmSourceProfileEntry.setDescription("Details about a particular SSPM Source Profile\nconfiguration.  Entries must exist in this table\nin order to be referenced by rows in the\nsspmSourceControlTable.")
sspmSourceProfileInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: sspmSourceProfileInstance.setDescription("An arbitrary index.")
sspmSourceProfileType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 2), AppLocalIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileType.setDescription("The AppLocalIndex value that uniquely identifies the\nmeasurement per the APM-MIB.  In order to create a row\nin this table, there must be a corresponding row in the\nsspmCapabilitiesTable.\n\nWhen attempting to set this object, if no\ncorresponding row exists in the sspmCapabilitiesTable,\nthen the agent should return a 'badValue' error.")
sspmSourceProfilePacketSize = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 3), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketSize.setDescription("The size of packet to be transmitted in bytes.  The\nsize accounts for all data within the IPv4 or IPv6\npayloads, excluding the IP headers, IP header options\nand link-level protocol headers.\n\nIf the size is set smaller than the minimum allowed\npacket size or greater than the maximum allowed\npacket size, then the set should fail, and the agent\nshould return a 'badValue' error.")
sspmSourceProfilePacketFillType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(3,2,1,)).subtype(namedValues=NamedValues(("random", 1), ("pattern", 2), ("url", 3), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketFillType.setDescription("Indicates how the packet is filled.\n\n'random' indicates that the packet contains random\ndata patterns.  This is probe and implementation\ndependent.\n\n\n\n\n'pattern' indicates that the pattern defined in the\nsspmSourceProfilePacketFillValue attribute is used to\nfill the packet.\n\n'url' indicates that the value of\nsspmSourceProfilePacketFillValue should\ncontain a URL.  The contents of the document\nat that URL are retrieved when sspmSourceStatus becomes\nactive and utilized in the packet.  If the attempt to\naccess that URL fails, then the row status is set to\n'notReady', and the set should fail with\n'inconsistentValue'.  This value must contain a\ndereferencable URL of the type 'http:', 'https:', or\n'ftp:' only.")
sspmSourceProfilePacketFillValue = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePacketFillValue.setDescription("The string value with which to fill the packet.  If\nsspmSourceProfilePacketFillType is set to 'pattern',\nthen this pattern is repeated until the packet is\nsspmSourcePacketSize in bytes.  Note that if the\nlength of the octet string specified for this\nvalue does not divide evenly into the packet\nsize, then an incomplete last copy of this data\nmay be copied into the packet.  If the value of\nsspmSourceProfilePacketFillType is set to 'random', then\nthis attribute is unused.  If the value of the\nsspmSourceProfilePacketFillType is set to 'url', then\nthe URL specified in this attribute is retrieved\nand used by the probe.  In the case of a URL, this value\nmust contain a dereferencable URL of the type\n'http:', 'https:', or 'ftp:' only.")
sspmSourceProfileTOS = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileTOS.setDescription("Represents the TOS field in the IP packet header.  The\nvalue of this object defaults to zero if not set.")
sspmSourceProfileFlowLabel = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575)).clone(0)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileFlowLabel.setDescription("This object is used to specify the Flow Label in a IPv6\npacket (RFC 2460) to force special handling by the IPv6\nrouters; e.g., non-default quality-of-service handling.\n\nThis object is meaningful only when the object\nsspmSourceDestAddressType is IPv6(2).\nThe value of this object defaults to zero if not set.")
sspmSourceProfileLooseSrcRteFill = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteFill.setDescription("In the event that the test should run over a\nspecific route, the intent is to force the route using the\nLoose Source Route option in IPv4 [RFC791] and\nIPv6 [RFC2460].  This object contains a\nseries of IP addresses along the path that would be\nput into the loose source route option in the IP header.\n\nThe IPv4 addresses are to be listed as 32-bit\naddress values, and the IPv6 addresses are to be\nlisted as a string of 128-bit addresses.  The\nmaximum length allowed within the IPv4 source route\noption is 63 addresses.  To simply account for\nIPv6 addresses as well, the maximum length of the\noctet string is 240.  This allows up to 60\nIPv4 addresses or up to 15 IPv6 addresses in the\nstring.")
sspmSourceProfileLooseSrcRteLen = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 240))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileLooseSrcRteLen.setDescription("In the event that the test should run over a\nspecific route, the intent is to force the route.\nThis attribute specifies the length of data to\nbe copied from the sspmSourceProfileLooseSrcRteFill\ninto the route data fields of the loose source route\n\n\n\noptions in the IPv4 or IPv6 headers.")
sspmSourceProfileTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileTTL.setDescription("If non-zero, this specifies the value to place into\nthe TTL field on transmission.")
sspmSourceProfileNoFrag = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 11), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileNoFrag.setDescription("When true, the 'Don't Fragment Bit' should be set\non the packet header.")
sspmSourceProfile8021Tagging = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfile8021Tagging.setDescription("IEEE 802.1Q tagging used in IEEE 802.1D bridged\nenvironments.\n\nA value of -1 indicates that the packets are untagged.\n\nA value of 0 to 65535 is the value of the tag to be\ninserted in the tagged packets.\n\nNote that according to IEEE 802.1Q, VLAN-ID tags with\na value of 4095 shall not be transmitted on the wire.\nAs the VLAN-ID is encoded in the 12 least significant\nbits on the tag, values that translate in a binary\nrepresentation of all 1's in the last 12 bits\nSHALL NOT be configured.  In this case, the set should\nfail, and return an error-status of 'inconsistentValue'.")
sspmSourceProfileUsername = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 13), Utf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileUsername.setDescription("An optional username used by the application protocol.")
sspmSourceProfilePassword = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 14), Utf8String()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfilePassword.setDescription("An optional password used by the application protocol.")
sspmSourceProfileParameter = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileParameter.setDescription("An optional parameter used by the application protocol.\nFor DNS, this would be the hostname or IP.  For HTTP,\nthis would be the URL.  For nntp, this would be the\nnews group.  For TCP, this would be the port number.\nFor SMTP, this would be the recipient (and could\nassume the message is predefined).")
sspmSourceProfileOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 16), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileOwner.setDescription("Name of the management station/application that\nset up the profile.")
sspmSourceProfileStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 17), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileStorageType.setDescription("The storage type of this sspmSourceProfileEntry.  If the\nvalue of this object is 'permanent', no objects in this row\nneed to be writable.")
sspmSourceProfileStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 1, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceProfileStatus.setDescription("Status of this profile.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nOnce this object is set to active(1), no objects in the\nsspmSourceProfileTable can be changed.")
sspmSourceControlTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2))
if mibBuilder.loadTexts: sspmSourceControlTable.setDescription("The table of SSPM measurements configured.")
sspmSourceControlEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1)).setIndexNames((0, "SSPM-MIB", "sspmSourceControlInstance"))
if mibBuilder.loadTexts: sspmSourceControlEntry.setDescription("Details about a particular SSPM configuration.")
sspmSourceControlInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: sspmSourceControlInstance.setDescription("An arbitrary index.")
sspmSourceControlProfile = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlProfile.setDescription("A pointer to the profile (sspmSourceProfileEntry) that\nthis control entry uses to define the test being\nperformed.")
sspmSourceControlSrc = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlSrc.setDescription("The ifIndex where the packet should originate from the\nprobe (if it matters).  A value of zero indicates that\nit does not matter and that the device decides.")
sspmSourceControlDestAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlDestAddrType.setDescription("The type of Internet address by which the destination\nis accessed.")
sspmSourceControlDestAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlDestAddr.setDescription("The Internet address for the destination.  The formatting\nof this object is controlled by the\nsspmSourceControlDestAddrType object above.\n\n\n\n\nWhen this object contains a DNS name, then the name is\nresolved to an address each time measurement is to be made.\nFurther, the agent should not cache this address,\nbut instead should perform the resolution prior to each\nmeasurement.")
sspmSourceControlEnabled = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlEnabled.setDescription("When set to 'true', this test is enabled.  When set to\n'false', it is disabled.")
sspmSourceControlTimeOut = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 7), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlTimeOut.setDescription("Timeout value for the measurement response.  If no\nresponse is received in the time specified, then\nthe test fails.")
sspmSourceControlSamplingDist = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("deterministic", 1), ("poisson", 2), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlSamplingDist.setDescription("When this attribute is set to 'deterministic', then\npackets are generated at with a fixed inter-packet\ninjection time specified by sspmSourceFrequency.\n\nWhen this attribute is set to 'Poisson', then packets\nare generated with inter-packet injection times sampled\nfrom an exponential distribution with the single\ndistributional parameter determined by the inverse\nfrequency).")
sspmSourceControlFrequency = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 9), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlFrequency.setDescription("The inverse of this value is the rate at which packets\nare generated.  Refer to sspmSourceSamplingDistribution.\nIf the value set is less than the value of\nsspmGeneralMinFrequency, then the set will fail with an\nerror-status of 'inconsistentValue'.")
sspmSourceControlFirstSeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 10), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlFirstSeqNum.setDescription("The first sequence number of packets to be transmitted.")
sspmSourceControlLastSeqNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSourceControlLastSeqNum.setDescription("The last sequence number transmitted.  This value is updated\nby the agent after packet generation.")
sspmSourceControlOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 12), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlOwner.setDescription("Name of the management station/application that set\nup the test.")
sspmSourceControlStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 13), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlStorageType.setDescription("The storage type of this sspmSourceControlEntry.  If the\nvalue of this object is 'permanent', no objects in this row\nneed to be writable.")
sspmSourceControlStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 2, 2, 1, 14), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSourceControlStatus.setDescription("Status of this source control entry.\n\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nWhen this attribute has the value of\n'active', none of the read-write or read-create attributes\nin this table may be modified, with the exception of\nsspmSourceControlEnabled.")
sspmSink = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 1, 5))
sspmSinkTable = MibTable((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1))
if mibBuilder.loadTexts: sspmSinkTable.setDescription("A table configuring the sink for measurements.")
sspmSinkEntry = MibTableRow((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1)).setIndexNames((0, "SSPM-MIB", "sspmSinkInstance"))
if mibBuilder.loadTexts: sspmSinkEntry.setDescription("The details of a particular sink entry.  If the measurement\nis a round-trip type, then the sink entry will be on the\nsame probe as the corresponding sspmSourceEntry.  If the\nmeasurement is a one-way, type then the sink entry will be\non a different probe.")
sspmSinkInstance = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: sspmSinkInstance.setDescription("An index.  When the measurement is for a round-trip\nmeasurement, then this table entry is on the same probe as\nthe corresponding sspmSourceEntry, and the value of this\nattribute should correspond to the value of\nsspmSourceInstance.  Management applications configuring\nsinks for one-way measurements could define some\nscheme whereby the sspmSinkInstance is unique across\nall probes.  Note that the unique key to this entry is\nalso constructed with sspmSinkType,\nsspmSinkSourceAddressType, and sspmSinkSourceAddress.\nTo make the implementation simpler, those other\nattributes are not included in the index but uniqueness\nis still needed to receive all the packets.")
sspmSinkType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 2), AppLocalIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkType.setDescription("The AppLocalIndex value that uniquely identifies the\nmeasurement per the APM-MIB.  In order to create a row\nin this table, there must be a corresponding row in the\nsspmCapabilitiesTable.  If there is no corresponding\nrow in the sspmCapabilitiestable, then the agent will\nreturn an error-status of 'inconsistentValue'.")
sspmSinkSourceAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 3), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkSourceAddressType.setDescription("The type of Internet address of the source.")
sspmSinkSourceAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 4), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkSourceAddress.setDescription("The Internet address of the source.  The formatting\nof this object is controlled by the sspmSinkSourceAddressType\nobject above.\n\nThis object should be set only to a valid device address\nthat has been administratively configured into the\ndevice.  If a set attempts to set this object to an\naddress that does not belong (i.e., is not administratively\nconfigured into the device), the set should fail, and the\nagent should return a error-status of 'inconsistentValue'.")
sspmSinkExpectedRate = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 5), SspmMicroSeconds()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkExpectedRate.setDescription("The expected rate at which packets will arrive.")
sspmSinkEnable = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 6), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkEnable.setDescription("Indicates if the sink is enabled or not.")
sspmSinkExpectedFirstSequenceNum = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 7), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkExpectedFirstSequenceNum.setDescription("The expected first sequence number of packets.\nThis is used by the sink to determine if packets\nwere lost at the initiation of the test.")
sspmSinkLastSequenceNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSinkLastSequenceNumber.setDescription("The last sequence number received.")
sspmSinkLastSequenceInvalid = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sspmSinkLastSequenceInvalid.setDescription("The number of packets that arrived whose\nsequence number was not one plus the value of\nsspmSinkLastSequenceNumber.")
sspmSinkStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 10), StorageType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkStorageType.setDescription("The storage type of this sspmSinkEntry.  If the value\nof this object is 'permanent', no objects in this row\nneed to be writable.")
sspmSinkStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 16, 28, 1, 5, 1, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sspmSinkStatus.setDescription("Status of this conceptual row.\nAn entry may not exist in the active state unless all\nobjects in the entry have an appropriate value.\n\nOnce this object is set to active(1), no objects with\nMAX-ACCESS of read-create in the sspmSinkTable can\nbe changed.")
sspmMIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 2))
sspmMIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3))
sspmCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3, 1))
sspmGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 16, 28, 3, 2))

# Augmentions

# Groups

sspmGeneralGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 1)).setObjects(*(("SSPM-MIB", "sspmGeneralClockMaxSkew"), ("SSPM-MIB", "sspmGeneralClockSource"), ("SSPM-MIB", "sspmGeneralMinFrequency"), ("SSPM-MIB", "sspmGeneralClockResolution"), ("SSPM-MIB", "sspmCapabilitiesInstance"), ) )
if mibBuilder.loadTexts: sspmGeneralGroup.setDescription("The objects in the SSPM General Group.")
sspmSourceGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 2)).setObjects(*(("SSPM-MIB", "sspmSourceControlDestAddrType"), ("SSPM-MIB", "sspmSourceControlFrequency"), ("SSPM-MIB", "sspmSourceProfileStatus"), ("SSPM-MIB", "sspmSourceProfileOwner"), ("SSPM-MIB", "sspmSourceProfileLooseSrcRteLen"), ("SSPM-MIB", "sspmSourceControlSamplingDist"), ("SSPM-MIB", "sspmSourceProfilePassword"), ("SSPM-MIB", "sspmSourceProfilePacketFillType"), ("SSPM-MIB", "sspmSourceControlFirstSeqNum"), ("SSPM-MIB", "sspmSourceProfileType"), ("SSPM-MIB", "sspmSourceProfileUsername"), ("SSPM-MIB", "sspmSourceProfileTTL"), ("SSPM-MIB", "sspmSourceControlStatus"), ("SSPM-MIB", "sspmSourceProfilePacketFillValue"), ("SSPM-MIB", "sspmSourceProfileParameter"), ("SSPM-MIB", "sspmSourceProfilePacketSize"), ("SSPM-MIB", "sspmSourceProfileLooseSrcRteFill"), ("SSPM-MIB", "sspmSourceProfileStorageType"), ("SSPM-MIB", "sspmSourceControlLastSeqNum"), ("SSPM-MIB", "sspmSourceProfile8021Tagging"), ("SSPM-MIB", "sspmSourceProfileFlowLabel"), ("SSPM-MIB", "sspmSourceProfileNoFrag"), ("SSPM-MIB", "sspmSourceControlDestAddr"), ("SSPM-MIB", "sspmSourceControlProfile"), ("SSPM-MIB", "sspmSourceControlSrc"), ("SSPM-MIB", "sspmSourceControlOwner"), ("SSPM-MIB", "sspmSourceControlStorageType"), ("SSPM-MIB", "sspmSourceControlTimeOut"), ("SSPM-MIB", "sspmSourceControlEnabled"), ("SSPM-MIB", "sspmSourceProfileTOS"), ) )
if mibBuilder.loadTexts: sspmSourceGroup.setDescription("The objects in the SSPM Source Group.")
sspmUserPassGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 3)).setObjects(*(("SSPM-MIB", "sspmSourceProfilePassword"), ("SSPM-MIB", "sspmSourceProfileUsername"), ) )
if mibBuilder.loadTexts: sspmUserPassGroup.setDescription("The objects in the SSPM Username and password group.")
sspmSinkGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 16, 28, 3, 2, 4)).setObjects(*(("SSPM-MIB", "sspmSinkLastSequenceNumber"), ("SSPM-MIB", "sspmSinkEnable"), ("SSPM-MIB", "sspmSinkStorageType"), ("SSPM-MIB", "sspmSinkLastSequenceInvalid"), ("SSPM-MIB", "sspmSinkExpectedRate"), ("SSPM-MIB", "sspmSinkType"), ("SSPM-MIB", "sspmSinkStatus"), ("SSPM-MIB", "sspmSinkSourceAddress"), ("SSPM-MIB", "sspmSinkSourceAddressType"), ("SSPM-MIB", "sspmSinkExpectedFirstSequenceNum"), ) )
if mibBuilder.loadTexts: sspmSinkGroup.setDescription("The objects in the SSPM Sink Group.")

# Compliances

sspmGeneralCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 1)).setObjects(*(("SSPM-MIB", "sspmSinkGroup"), ("SSPM-MIB", "sspmSourceGroup"), ("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmUserPassGroup"), ) )
if mibBuilder.loadTexts: sspmGeneralCompliance.setDescription("A general compliance that allows all things to be optional.")
sspmSourceFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 2)).setObjects(*(("SSPM-MIB", "sspmSourceGroup"), ("SSPM-MIB", "sspmGeneralGroup"), ("SSPM-MIB", "sspmUserPassGroup"), ) )
if mibBuilder.loadTexts: sspmSourceFullCompliance.setDescription("A source compliance.  Use this compliance when implementing\na traffic-source-only device.  This is useful for implementing\ndevices that probe other devices for intrusive application\nmonitoring.  It is also useful for implementing the source\nof one-way tests used with a sink-only device.")
sspmSinkFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 16, 28, 3, 1, 3)).setObjects(*(("SSPM-MIB", "sspmSinkGroup"), ("SSPM-MIB", "sspmGeneralGroup"), ) )
if mibBuilder.loadTexts: sspmSinkFullCompliance.setDescription("A sink-only compliance.  Use this compliance when implementing a\nsink-only device.  This is useful for devices to receive one-way\nmeasurements.")

# Exports

# Module identity
mibBuilder.exportSymbols("SSPM-MIB", PYSNMP_MODULE_ID=sspmMIB)

# Types
mibBuilder.exportSymbols("SSPM-MIB", SspmClockMaxSkew=SspmClockMaxSkew, SspmClockSource=SspmClockSource, SspmMicroSeconds=SspmMicroSeconds)

# Objects
mibBuilder.exportSymbols("SSPM-MIB", sspmMIB=sspmMIB, sspmMIBObjects=sspmMIBObjects, sspmGeneral=sspmGeneral, sspmGeneralClockResolution=sspmGeneralClockResolution, sspmGeneralClockMaxSkew=sspmGeneralClockMaxSkew, sspmGeneralClockSource=sspmGeneralClockSource, sspmGeneralMinFrequency=sspmGeneralMinFrequency, sspmCapabilitiesTable=sspmCapabilitiesTable, sspmCapabilitiesEntry=sspmCapabilitiesEntry, sspmCapabilitiesInstance=sspmCapabilitiesInstance, sspmSource=sspmSource, sspmSourceProfileTable=sspmSourceProfileTable, sspmSourceProfileEntry=sspmSourceProfileEntry, sspmSourceProfileInstance=sspmSourceProfileInstance, sspmSourceProfileType=sspmSourceProfileType, sspmSourceProfilePacketSize=sspmSourceProfilePacketSize, sspmSourceProfilePacketFillType=sspmSourceProfilePacketFillType, sspmSourceProfilePacketFillValue=sspmSourceProfilePacketFillValue, sspmSourceProfileTOS=sspmSourceProfileTOS, sspmSourceProfileFlowLabel=sspmSourceProfileFlowLabel, sspmSourceProfileLooseSrcRteFill=sspmSourceProfileLooseSrcRteFill, sspmSourceProfileLooseSrcRteLen=sspmSourceProfileLooseSrcRteLen, sspmSourceProfileTTL=sspmSourceProfileTTL, sspmSourceProfileNoFrag=sspmSourceProfileNoFrag, sspmSourceProfile8021Tagging=sspmSourceProfile8021Tagging, sspmSourceProfileUsername=sspmSourceProfileUsername, sspmSourceProfilePassword=sspmSourceProfilePassword, sspmSourceProfileParameter=sspmSourceProfileParameter, sspmSourceProfileOwner=sspmSourceProfileOwner, sspmSourceProfileStorageType=sspmSourceProfileStorageType, sspmSourceProfileStatus=sspmSourceProfileStatus, sspmSourceControlTable=sspmSourceControlTable, sspmSourceControlEntry=sspmSourceControlEntry, sspmSourceControlInstance=sspmSourceControlInstance, sspmSourceControlProfile=sspmSourceControlProfile, sspmSourceControlSrc=sspmSourceControlSrc, sspmSourceControlDestAddrType=sspmSourceControlDestAddrType, sspmSourceControlDestAddr=sspmSourceControlDestAddr, sspmSourceControlEnabled=sspmSourceControlEnabled, sspmSourceControlTimeOut=sspmSourceControlTimeOut, sspmSourceControlSamplingDist=sspmSourceControlSamplingDist, sspmSourceControlFrequency=sspmSourceControlFrequency, sspmSourceControlFirstSeqNum=sspmSourceControlFirstSeqNum, sspmSourceControlLastSeqNum=sspmSourceControlLastSeqNum, sspmSourceControlOwner=sspmSourceControlOwner, sspmSourceControlStorageType=sspmSourceControlStorageType, sspmSourceControlStatus=sspmSourceControlStatus, sspmSink=sspmSink, sspmSinkTable=sspmSinkTable, sspmSinkEntry=sspmSinkEntry, sspmSinkInstance=sspmSinkInstance, sspmSinkType=sspmSinkType, sspmSinkSourceAddressType=sspmSinkSourceAddressType, sspmSinkSourceAddress=sspmSinkSourceAddress, sspmSinkExpectedRate=sspmSinkExpectedRate, sspmSinkEnable=sspmSinkEnable, sspmSinkExpectedFirstSequenceNum=sspmSinkExpectedFirstSequenceNum, sspmSinkLastSequenceNumber=sspmSinkLastSequenceNumber, sspmSinkLastSequenceInvalid=sspmSinkLastSequenceInvalid, sspmSinkStorageType=sspmSinkStorageType, sspmSinkStatus=sspmSinkStatus, sspmMIBNotifications=sspmMIBNotifications, sspmMIBConformance=sspmMIBConformance, sspmCompliances=sspmCompliances, sspmGroups=sspmGroups)

# Groups
mibBuilder.exportSymbols("SSPM-MIB", sspmGeneralGroup=sspmGeneralGroup, sspmSourceGroup=sspmSourceGroup, sspmUserPassGroup=sspmUserPassGroup, sspmSinkGroup=sspmSinkGroup)

# Compliances
mibBuilder.exportSymbols("SSPM-MIB", sspmGeneralCompliance=sspmGeneralCompliance, sspmSourceFullCompliance=sspmSourceFullCompliance, sspmSinkFullCompliance=sspmSinkFullCompliance)
